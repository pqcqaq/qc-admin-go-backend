// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"go-backend/database/ent/migrate"

	"go-backend/database/ent/apiauth"
	"go-backend/database/ent/attachment"
	"go-backend/database/ent/clientdevice"
	"go-backend/database/ent/credential"
	"go-backend/database/ent/logging"
	"go-backend/database/ent/loginrecord"
	"go-backend/database/ent/oauthapplication"
	"go-backend/database/ent/oauthauthorizationcode"
	"go-backend/database/ent/oauthprovider"
	"go-backend/database/ent/oauthstate"
	"go-backend/database/ent/oauthtoken"
	"go-backend/database/ent/oauthuser"
	"go-backend/database/ent/oauthuserauthorization"
	"go-backend/database/ent/permission"
	"go-backend/database/ent/role"
	"go-backend/database/ent/rolepermission"
	"go-backend/database/ent/scan"
	"go-backend/database/ent/scope"
	"go-backend/database/ent/systemmonitor"
	"go-backend/database/ent/user"
	"go-backend/database/ent/userrole"
	"go-backend/database/ent/verifycode"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// APIAuth is the client for interacting with the APIAuth builders.
	APIAuth *APIAuthClient
	// Attachment is the client for interacting with the Attachment builders.
	Attachment *AttachmentClient
	// ClientDevice is the client for interacting with the ClientDevice builders.
	ClientDevice *ClientDeviceClient
	// Credential is the client for interacting with the Credential builders.
	Credential *CredentialClient
	// Logging is the client for interacting with the Logging builders.
	Logging *LoggingClient
	// LoginRecord is the client for interacting with the LoginRecord builders.
	LoginRecord *LoginRecordClient
	// OauthApplication is the client for interacting with the OauthApplication builders.
	OauthApplication *OauthApplicationClient
	// OauthAuthorizationCode is the client for interacting with the OauthAuthorizationCode builders.
	OauthAuthorizationCode *OauthAuthorizationCodeClient
	// OauthProvider is the client for interacting with the OauthProvider builders.
	OauthProvider *OauthProviderClient
	// OauthState is the client for interacting with the OauthState builders.
	OauthState *OauthStateClient
	// OauthToken is the client for interacting with the OauthToken builders.
	OauthToken *OauthTokenClient
	// OauthUser is the client for interacting with the OauthUser builders.
	OauthUser *OauthUserClient
	// OauthUserAuthorization is the client for interacting with the OauthUserAuthorization builders.
	OauthUserAuthorization *OauthUserAuthorizationClient
	// Permission is the client for interacting with the Permission builders.
	Permission *PermissionClient
	// Role is the client for interacting with the Role builders.
	Role *RoleClient
	// RolePermission is the client for interacting with the RolePermission builders.
	RolePermission *RolePermissionClient
	// Scan is the client for interacting with the Scan builders.
	Scan *ScanClient
	// Scope is the client for interacting with the Scope builders.
	Scope *ScopeClient
	// SystemMonitor is the client for interacting with the SystemMonitor builders.
	SystemMonitor *SystemMonitorClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserRole is the client for interacting with the UserRole builders.
	UserRole *UserRoleClient
	// VerifyCode is the client for interacting with the VerifyCode builders.
	VerifyCode *VerifyCodeClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.APIAuth = NewAPIAuthClient(c.config)
	c.Attachment = NewAttachmentClient(c.config)
	c.ClientDevice = NewClientDeviceClient(c.config)
	c.Credential = NewCredentialClient(c.config)
	c.Logging = NewLoggingClient(c.config)
	c.LoginRecord = NewLoginRecordClient(c.config)
	c.OauthApplication = NewOauthApplicationClient(c.config)
	c.OauthAuthorizationCode = NewOauthAuthorizationCodeClient(c.config)
	c.OauthProvider = NewOauthProviderClient(c.config)
	c.OauthState = NewOauthStateClient(c.config)
	c.OauthToken = NewOauthTokenClient(c.config)
	c.OauthUser = NewOauthUserClient(c.config)
	c.OauthUserAuthorization = NewOauthUserAuthorizationClient(c.config)
	c.Permission = NewPermissionClient(c.config)
	c.Role = NewRoleClient(c.config)
	c.RolePermission = NewRolePermissionClient(c.config)
	c.Scan = NewScanClient(c.config)
	c.Scope = NewScopeClient(c.config)
	c.SystemMonitor = NewSystemMonitorClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserRole = NewUserRoleClient(c.config)
	c.VerifyCode = NewVerifyCodeClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		APIAuth:                NewAPIAuthClient(cfg),
		Attachment:             NewAttachmentClient(cfg),
		ClientDevice:           NewClientDeviceClient(cfg),
		Credential:             NewCredentialClient(cfg),
		Logging:                NewLoggingClient(cfg),
		LoginRecord:            NewLoginRecordClient(cfg),
		OauthApplication:       NewOauthApplicationClient(cfg),
		OauthAuthorizationCode: NewOauthAuthorizationCodeClient(cfg),
		OauthProvider:          NewOauthProviderClient(cfg),
		OauthState:             NewOauthStateClient(cfg),
		OauthToken:             NewOauthTokenClient(cfg),
		OauthUser:              NewOauthUserClient(cfg),
		OauthUserAuthorization: NewOauthUserAuthorizationClient(cfg),
		Permission:             NewPermissionClient(cfg),
		Role:                   NewRoleClient(cfg),
		RolePermission:         NewRolePermissionClient(cfg),
		Scan:                   NewScanClient(cfg),
		Scope:                  NewScopeClient(cfg),
		SystemMonitor:          NewSystemMonitorClient(cfg),
		User:                   NewUserClient(cfg),
		UserRole:               NewUserRoleClient(cfg),
		VerifyCode:             NewVerifyCodeClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		APIAuth:                NewAPIAuthClient(cfg),
		Attachment:             NewAttachmentClient(cfg),
		ClientDevice:           NewClientDeviceClient(cfg),
		Credential:             NewCredentialClient(cfg),
		Logging:                NewLoggingClient(cfg),
		LoginRecord:            NewLoginRecordClient(cfg),
		OauthApplication:       NewOauthApplicationClient(cfg),
		OauthAuthorizationCode: NewOauthAuthorizationCodeClient(cfg),
		OauthProvider:          NewOauthProviderClient(cfg),
		OauthState:             NewOauthStateClient(cfg),
		OauthToken:             NewOauthTokenClient(cfg),
		OauthUser:              NewOauthUserClient(cfg),
		OauthUserAuthorization: NewOauthUserAuthorizationClient(cfg),
		Permission:             NewPermissionClient(cfg),
		Role:                   NewRoleClient(cfg),
		RolePermission:         NewRolePermissionClient(cfg),
		Scan:                   NewScanClient(cfg),
		Scope:                  NewScopeClient(cfg),
		SystemMonitor:          NewSystemMonitorClient(cfg),
		User:                   NewUserClient(cfg),
		UserRole:               NewUserRoleClient(cfg),
		VerifyCode:             NewVerifyCodeClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		APIAuth.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.APIAuth, c.Attachment, c.ClientDevice, c.Credential, c.Logging, c.LoginRecord,
		c.OauthApplication, c.OauthAuthorizationCode, c.OauthProvider, c.OauthState,
		c.OauthToken, c.OauthUser, c.OauthUserAuthorization, c.Permission, c.Role,
		c.RolePermission, c.Scan, c.Scope, c.SystemMonitor, c.User, c.UserRole,
		c.VerifyCode,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.APIAuth, c.Attachment, c.ClientDevice, c.Credential, c.Logging, c.LoginRecord,
		c.OauthApplication, c.OauthAuthorizationCode, c.OauthProvider, c.OauthState,
		c.OauthToken, c.OauthUser, c.OauthUserAuthorization, c.Permission, c.Role,
		c.RolePermission, c.Scan, c.Scope, c.SystemMonitor, c.User, c.UserRole,
		c.VerifyCode,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *APIAuthMutation:
		return c.APIAuth.mutate(ctx, m)
	case *AttachmentMutation:
		return c.Attachment.mutate(ctx, m)
	case *ClientDeviceMutation:
		return c.ClientDevice.mutate(ctx, m)
	case *CredentialMutation:
		return c.Credential.mutate(ctx, m)
	case *LoggingMutation:
		return c.Logging.mutate(ctx, m)
	case *LoginRecordMutation:
		return c.LoginRecord.mutate(ctx, m)
	case *OauthApplicationMutation:
		return c.OauthApplication.mutate(ctx, m)
	case *OauthAuthorizationCodeMutation:
		return c.OauthAuthorizationCode.mutate(ctx, m)
	case *OauthProviderMutation:
		return c.OauthProvider.mutate(ctx, m)
	case *OauthStateMutation:
		return c.OauthState.mutate(ctx, m)
	case *OauthTokenMutation:
		return c.OauthToken.mutate(ctx, m)
	case *OauthUserMutation:
		return c.OauthUser.mutate(ctx, m)
	case *OauthUserAuthorizationMutation:
		return c.OauthUserAuthorization.mutate(ctx, m)
	case *PermissionMutation:
		return c.Permission.mutate(ctx, m)
	case *RoleMutation:
		return c.Role.mutate(ctx, m)
	case *RolePermissionMutation:
		return c.RolePermission.mutate(ctx, m)
	case *ScanMutation:
		return c.Scan.mutate(ctx, m)
	case *ScopeMutation:
		return c.Scope.mutate(ctx, m)
	case *SystemMonitorMutation:
		return c.SystemMonitor.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserRoleMutation:
		return c.UserRole.mutate(ctx, m)
	case *VerifyCodeMutation:
		return c.VerifyCode.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// APIAuthClient is a client for the APIAuth schema.
type APIAuthClient struct {
	config
}

// NewAPIAuthClient returns a client for the APIAuth from the given config.
func NewAPIAuthClient(c config) *APIAuthClient {
	return &APIAuthClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `apiauth.Hooks(f(g(h())))`.
func (c *APIAuthClient) Use(hooks ...Hook) {
	c.hooks.APIAuth = append(c.hooks.APIAuth, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `apiauth.Intercept(f(g(h())))`.
func (c *APIAuthClient) Intercept(interceptors ...Interceptor) {
	c.inters.APIAuth = append(c.inters.APIAuth, interceptors...)
}

// Create returns a builder for creating a APIAuth entity.
func (c *APIAuthClient) Create() *APIAuthCreate {
	mutation := newAPIAuthMutation(c.config, OpCreate)
	return &APIAuthCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of APIAuth entities.
func (c *APIAuthClient) CreateBulk(builders ...*APIAuthCreate) *APIAuthCreateBulk {
	return &APIAuthCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *APIAuthClient) MapCreateBulk(slice any, setFunc func(*APIAuthCreate, int)) *APIAuthCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &APIAuthCreateBulk{err: fmt.Errorf("calling to APIAuthClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*APIAuthCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &APIAuthCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for APIAuth.
func (c *APIAuthClient) Update() *APIAuthUpdate {
	mutation := newAPIAuthMutation(c.config, OpUpdate)
	return &APIAuthUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *APIAuthClient) UpdateOne(_m *APIAuth) *APIAuthUpdateOne {
	mutation := newAPIAuthMutation(c.config, OpUpdateOne, withAPIAuth(_m))
	return &APIAuthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *APIAuthClient) UpdateOneID(id uint64) *APIAuthUpdateOne {
	mutation := newAPIAuthMutation(c.config, OpUpdateOne, withAPIAuthID(id))
	return &APIAuthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for APIAuth.
func (c *APIAuthClient) Delete() *APIAuthDelete {
	mutation := newAPIAuthMutation(c.config, OpDelete)
	return &APIAuthDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *APIAuthClient) DeleteOne(_m *APIAuth) *APIAuthDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *APIAuthClient) DeleteOneID(id uint64) *APIAuthDeleteOne {
	builder := c.Delete().Where(apiauth.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &APIAuthDeleteOne{builder}
}

// Query returns a query builder for APIAuth.
func (c *APIAuthClient) Query() *APIAuthQuery {
	return &APIAuthQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAPIAuth},
		inters: c.Interceptors(),
	}
}

// Get returns a APIAuth entity by its id.
func (c *APIAuthClient) Get(ctx context.Context, id uint64) (*APIAuth, error) {
	return c.Query().Where(apiauth.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *APIAuthClient) GetX(ctx context.Context, id uint64) *APIAuth {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPermissions queries the permissions edge of a APIAuth.
func (c *APIAuthClient) QueryPermissions(_m *APIAuth) *PermissionQuery {
	query := (&PermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(apiauth.Table, apiauth.FieldID, id),
			sqlgraph.To(permission.Table, permission.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, apiauth.PermissionsTable, apiauth.PermissionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *APIAuthClient) Hooks() []Hook {
	hooks := c.hooks.APIAuth
	return append(hooks[:len(hooks):len(hooks)], apiauth.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *APIAuthClient) Interceptors() []Interceptor {
	inters := c.inters.APIAuth
	return append(inters[:len(inters):len(inters)], apiauth.Interceptors[:]...)
}

func (c *APIAuthClient) mutate(ctx context.Context, m *APIAuthMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&APIAuthCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&APIAuthUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&APIAuthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&APIAuthDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown APIAuth mutation op: %q", m.Op())
	}
}

// AttachmentClient is a client for the Attachment schema.
type AttachmentClient struct {
	config
}

// NewAttachmentClient returns a client for the Attachment from the given config.
func NewAttachmentClient(c config) *AttachmentClient {
	return &AttachmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `attachment.Hooks(f(g(h())))`.
func (c *AttachmentClient) Use(hooks ...Hook) {
	c.hooks.Attachment = append(c.hooks.Attachment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `attachment.Intercept(f(g(h())))`.
func (c *AttachmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Attachment = append(c.inters.Attachment, interceptors...)
}

// Create returns a builder for creating a Attachment entity.
func (c *AttachmentClient) Create() *AttachmentCreate {
	mutation := newAttachmentMutation(c.config, OpCreate)
	return &AttachmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Attachment entities.
func (c *AttachmentClient) CreateBulk(builders ...*AttachmentCreate) *AttachmentCreateBulk {
	return &AttachmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AttachmentClient) MapCreateBulk(slice any, setFunc func(*AttachmentCreate, int)) *AttachmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AttachmentCreateBulk{err: fmt.Errorf("calling to AttachmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AttachmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AttachmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Attachment.
func (c *AttachmentClient) Update() *AttachmentUpdate {
	mutation := newAttachmentMutation(c.config, OpUpdate)
	return &AttachmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AttachmentClient) UpdateOne(_m *Attachment) *AttachmentUpdateOne {
	mutation := newAttachmentMutation(c.config, OpUpdateOne, withAttachment(_m))
	return &AttachmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AttachmentClient) UpdateOneID(id uint64) *AttachmentUpdateOne {
	mutation := newAttachmentMutation(c.config, OpUpdateOne, withAttachmentID(id))
	return &AttachmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Attachment.
func (c *AttachmentClient) Delete() *AttachmentDelete {
	mutation := newAttachmentMutation(c.config, OpDelete)
	return &AttachmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AttachmentClient) DeleteOne(_m *Attachment) *AttachmentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AttachmentClient) DeleteOneID(id uint64) *AttachmentDeleteOne {
	builder := c.Delete().Where(attachment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AttachmentDeleteOne{builder}
}

// Query returns a query builder for Attachment.
func (c *AttachmentClient) Query() *AttachmentQuery {
	return &AttachmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAttachment},
		inters: c.Interceptors(),
	}
}

// Get returns a Attachment entity by its id.
func (c *AttachmentClient) Get(ctx context.Context, id uint64) (*Attachment, error) {
	return c.Query().Where(attachment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AttachmentClient) GetX(ctx context.Context, id uint64) *Attachment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AttachmentClient) Hooks() []Hook {
	hooks := c.hooks.Attachment
	return append(hooks[:len(hooks):len(hooks)], attachment.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AttachmentClient) Interceptors() []Interceptor {
	inters := c.inters.Attachment
	return append(inters[:len(inters):len(inters)], attachment.Interceptors[:]...)
}

func (c *AttachmentClient) mutate(ctx context.Context, m *AttachmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AttachmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AttachmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AttachmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AttachmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Attachment mutation op: %q", m.Op())
	}
}

// ClientDeviceClient is a client for the ClientDevice schema.
type ClientDeviceClient struct {
	config
}

// NewClientDeviceClient returns a client for the ClientDevice from the given config.
func NewClientDeviceClient(c config) *ClientDeviceClient {
	return &ClientDeviceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `clientdevice.Hooks(f(g(h())))`.
func (c *ClientDeviceClient) Use(hooks ...Hook) {
	c.hooks.ClientDevice = append(c.hooks.ClientDevice, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `clientdevice.Intercept(f(g(h())))`.
func (c *ClientDeviceClient) Intercept(interceptors ...Interceptor) {
	c.inters.ClientDevice = append(c.inters.ClientDevice, interceptors...)
}

// Create returns a builder for creating a ClientDevice entity.
func (c *ClientDeviceClient) Create() *ClientDeviceCreate {
	mutation := newClientDeviceMutation(c.config, OpCreate)
	return &ClientDeviceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ClientDevice entities.
func (c *ClientDeviceClient) CreateBulk(builders ...*ClientDeviceCreate) *ClientDeviceCreateBulk {
	return &ClientDeviceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ClientDeviceClient) MapCreateBulk(slice any, setFunc func(*ClientDeviceCreate, int)) *ClientDeviceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ClientDeviceCreateBulk{err: fmt.Errorf("calling to ClientDeviceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ClientDeviceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ClientDeviceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ClientDevice.
func (c *ClientDeviceClient) Update() *ClientDeviceUpdate {
	mutation := newClientDeviceMutation(c.config, OpUpdate)
	return &ClientDeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClientDeviceClient) UpdateOne(_m *ClientDevice) *ClientDeviceUpdateOne {
	mutation := newClientDeviceMutation(c.config, OpUpdateOne, withClientDevice(_m))
	return &ClientDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClientDeviceClient) UpdateOneID(id uint64) *ClientDeviceUpdateOne {
	mutation := newClientDeviceMutation(c.config, OpUpdateOne, withClientDeviceID(id))
	return &ClientDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ClientDevice.
func (c *ClientDeviceClient) Delete() *ClientDeviceDelete {
	mutation := newClientDeviceMutation(c.config, OpDelete)
	return &ClientDeviceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ClientDeviceClient) DeleteOne(_m *ClientDevice) *ClientDeviceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ClientDeviceClient) DeleteOneID(id uint64) *ClientDeviceDeleteOne {
	builder := c.Delete().Where(clientdevice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClientDeviceDeleteOne{builder}
}

// Query returns a query builder for ClientDevice.
func (c *ClientDeviceClient) Query() *ClientDeviceQuery {
	return &ClientDeviceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeClientDevice},
		inters: c.Interceptors(),
	}
}

// Get returns a ClientDevice entity by its id.
func (c *ClientDeviceClient) Get(ctx context.Context, id uint64) (*ClientDevice, error) {
	return c.Query().Where(clientdevice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClientDeviceClient) GetX(ctx context.Context, id uint64) *ClientDevice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoles queries the roles edge of a ClientDevice.
func (c *ClientDeviceClient) QueryRoles(_m *ClientDevice) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(clientdevice.Table, clientdevice.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, clientdevice.RolesTable, clientdevice.RolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ClientDeviceClient) Hooks() []Hook {
	hooks := c.hooks.ClientDevice
	return append(hooks[:len(hooks):len(hooks)], clientdevice.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ClientDeviceClient) Interceptors() []Interceptor {
	inters := c.inters.ClientDevice
	return append(inters[:len(inters):len(inters)], clientdevice.Interceptors[:]...)
}

func (c *ClientDeviceClient) mutate(ctx context.Context, m *ClientDeviceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ClientDeviceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ClientDeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ClientDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ClientDeviceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ClientDevice mutation op: %q", m.Op())
	}
}

// CredentialClient is a client for the Credential schema.
type CredentialClient struct {
	config
}

// NewCredentialClient returns a client for the Credential from the given config.
func NewCredentialClient(c config) *CredentialClient {
	return &CredentialClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `credential.Hooks(f(g(h())))`.
func (c *CredentialClient) Use(hooks ...Hook) {
	c.hooks.Credential = append(c.hooks.Credential, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `credential.Intercept(f(g(h())))`.
func (c *CredentialClient) Intercept(interceptors ...Interceptor) {
	c.inters.Credential = append(c.inters.Credential, interceptors...)
}

// Create returns a builder for creating a Credential entity.
func (c *CredentialClient) Create() *CredentialCreate {
	mutation := newCredentialMutation(c.config, OpCreate)
	return &CredentialCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Credential entities.
func (c *CredentialClient) CreateBulk(builders ...*CredentialCreate) *CredentialCreateBulk {
	return &CredentialCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CredentialClient) MapCreateBulk(slice any, setFunc func(*CredentialCreate, int)) *CredentialCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CredentialCreateBulk{err: fmt.Errorf("calling to CredentialClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CredentialCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CredentialCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Credential.
func (c *CredentialClient) Update() *CredentialUpdate {
	mutation := newCredentialMutation(c.config, OpUpdate)
	return &CredentialUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CredentialClient) UpdateOne(_m *Credential) *CredentialUpdateOne {
	mutation := newCredentialMutation(c.config, OpUpdateOne, withCredential(_m))
	return &CredentialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CredentialClient) UpdateOneID(id uint64) *CredentialUpdateOne {
	mutation := newCredentialMutation(c.config, OpUpdateOne, withCredentialID(id))
	return &CredentialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Credential.
func (c *CredentialClient) Delete() *CredentialDelete {
	mutation := newCredentialMutation(c.config, OpDelete)
	return &CredentialDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CredentialClient) DeleteOne(_m *Credential) *CredentialDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CredentialClient) DeleteOneID(id uint64) *CredentialDeleteOne {
	builder := c.Delete().Where(credential.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CredentialDeleteOne{builder}
}

// Query returns a query builder for Credential.
func (c *CredentialClient) Query() *CredentialQuery {
	return &CredentialQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCredential},
		inters: c.Interceptors(),
	}
}

// Get returns a Credential entity by its id.
func (c *CredentialClient) Get(ctx context.Context, id uint64) (*Credential, error) {
	return c.Query().Where(credential.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CredentialClient) GetX(ctx context.Context, id uint64) *Credential {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Credential.
func (c *CredentialClient) QueryUser(_m *Credential) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(credential.Table, credential.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, credential.UserTable, credential.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CredentialClient) Hooks() []Hook {
	hooks := c.hooks.Credential
	return append(hooks[:len(hooks):len(hooks)], credential.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CredentialClient) Interceptors() []Interceptor {
	inters := c.inters.Credential
	return append(inters[:len(inters):len(inters)], credential.Interceptors[:]...)
}

func (c *CredentialClient) mutate(ctx context.Context, m *CredentialMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CredentialCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CredentialUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CredentialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CredentialDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Credential mutation op: %q", m.Op())
	}
}

// LoggingClient is a client for the Logging schema.
type LoggingClient struct {
	config
}

// NewLoggingClient returns a client for the Logging from the given config.
func NewLoggingClient(c config) *LoggingClient {
	return &LoggingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `logging.Hooks(f(g(h())))`.
func (c *LoggingClient) Use(hooks ...Hook) {
	c.hooks.Logging = append(c.hooks.Logging, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `logging.Intercept(f(g(h())))`.
func (c *LoggingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Logging = append(c.inters.Logging, interceptors...)
}

// Create returns a builder for creating a Logging entity.
func (c *LoggingClient) Create() *LoggingCreate {
	mutation := newLoggingMutation(c.config, OpCreate)
	return &LoggingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Logging entities.
func (c *LoggingClient) CreateBulk(builders ...*LoggingCreate) *LoggingCreateBulk {
	return &LoggingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LoggingClient) MapCreateBulk(slice any, setFunc func(*LoggingCreate, int)) *LoggingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LoggingCreateBulk{err: fmt.Errorf("calling to LoggingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LoggingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LoggingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Logging.
func (c *LoggingClient) Update() *LoggingUpdate {
	mutation := newLoggingMutation(c.config, OpUpdate)
	return &LoggingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LoggingClient) UpdateOne(_m *Logging) *LoggingUpdateOne {
	mutation := newLoggingMutation(c.config, OpUpdateOne, withLogging(_m))
	return &LoggingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LoggingClient) UpdateOneID(id uint64) *LoggingUpdateOne {
	mutation := newLoggingMutation(c.config, OpUpdateOne, withLoggingID(id))
	return &LoggingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Logging.
func (c *LoggingClient) Delete() *LoggingDelete {
	mutation := newLoggingMutation(c.config, OpDelete)
	return &LoggingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LoggingClient) DeleteOne(_m *Logging) *LoggingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LoggingClient) DeleteOneID(id uint64) *LoggingDeleteOne {
	builder := c.Delete().Where(logging.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LoggingDeleteOne{builder}
}

// Query returns a query builder for Logging.
func (c *LoggingClient) Query() *LoggingQuery {
	return &LoggingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLogging},
		inters: c.Interceptors(),
	}
}

// Get returns a Logging entity by its id.
func (c *LoggingClient) Get(ctx context.Context, id uint64) (*Logging, error) {
	return c.Query().Where(logging.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LoggingClient) GetX(ctx context.Context, id uint64) *Logging {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *LoggingClient) Hooks() []Hook {
	hooks := c.hooks.Logging
	return append(hooks[:len(hooks):len(hooks)], logging.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *LoggingClient) Interceptors() []Interceptor {
	inters := c.inters.Logging
	return append(inters[:len(inters):len(inters)], logging.Interceptors[:]...)
}

func (c *LoggingClient) mutate(ctx context.Context, m *LoggingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LoggingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LoggingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LoggingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LoggingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Logging mutation op: %q", m.Op())
	}
}

// LoginRecordClient is a client for the LoginRecord schema.
type LoginRecordClient struct {
	config
}

// NewLoginRecordClient returns a client for the LoginRecord from the given config.
func NewLoginRecordClient(c config) *LoginRecordClient {
	return &LoginRecordClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `loginrecord.Hooks(f(g(h())))`.
func (c *LoginRecordClient) Use(hooks ...Hook) {
	c.hooks.LoginRecord = append(c.hooks.LoginRecord, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `loginrecord.Intercept(f(g(h())))`.
func (c *LoginRecordClient) Intercept(interceptors ...Interceptor) {
	c.inters.LoginRecord = append(c.inters.LoginRecord, interceptors...)
}

// Create returns a builder for creating a LoginRecord entity.
func (c *LoginRecordClient) Create() *LoginRecordCreate {
	mutation := newLoginRecordMutation(c.config, OpCreate)
	return &LoginRecordCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LoginRecord entities.
func (c *LoginRecordClient) CreateBulk(builders ...*LoginRecordCreate) *LoginRecordCreateBulk {
	return &LoginRecordCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LoginRecordClient) MapCreateBulk(slice any, setFunc func(*LoginRecordCreate, int)) *LoginRecordCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LoginRecordCreateBulk{err: fmt.Errorf("calling to LoginRecordClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LoginRecordCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LoginRecordCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LoginRecord.
func (c *LoginRecordClient) Update() *LoginRecordUpdate {
	mutation := newLoginRecordMutation(c.config, OpUpdate)
	return &LoginRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LoginRecordClient) UpdateOne(_m *LoginRecord) *LoginRecordUpdateOne {
	mutation := newLoginRecordMutation(c.config, OpUpdateOne, withLoginRecord(_m))
	return &LoginRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LoginRecordClient) UpdateOneID(id uint64) *LoginRecordUpdateOne {
	mutation := newLoginRecordMutation(c.config, OpUpdateOne, withLoginRecordID(id))
	return &LoginRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LoginRecord.
func (c *LoginRecordClient) Delete() *LoginRecordDelete {
	mutation := newLoginRecordMutation(c.config, OpDelete)
	return &LoginRecordDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LoginRecordClient) DeleteOne(_m *LoginRecord) *LoginRecordDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LoginRecordClient) DeleteOneID(id uint64) *LoginRecordDeleteOne {
	builder := c.Delete().Where(loginrecord.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LoginRecordDeleteOne{builder}
}

// Query returns a query builder for LoginRecord.
func (c *LoginRecordClient) Query() *LoginRecordQuery {
	return &LoginRecordQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLoginRecord},
		inters: c.Interceptors(),
	}
}

// Get returns a LoginRecord entity by its id.
func (c *LoginRecordClient) Get(ctx context.Context, id uint64) (*LoginRecord, error) {
	return c.Query().Where(loginrecord.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LoginRecordClient) GetX(ctx context.Context, id uint64) *LoginRecord {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a LoginRecord.
func (c *LoginRecordClient) QueryUser(_m *LoginRecord) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(loginrecord.Table, loginrecord.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, loginrecord.UserTable, loginrecord.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LoginRecordClient) Hooks() []Hook {
	hooks := c.hooks.LoginRecord
	return append(hooks[:len(hooks):len(hooks)], loginrecord.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *LoginRecordClient) Interceptors() []Interceptor {
	return c.inters.LoginRecord
}

func (c *LoginRecordClient) mutate(ctx context.Context, m *LoginRecordMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LoginRecordCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LoginRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LoginRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LoginRecordDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LoginRecord mutation op: %q", m.Op())
	}
}

// OauthApplicationClient is a client for the OauthApplication schema.
type OauthApplicationClient struct {
	config
}

// NewOauthApplicationClient returns a client for the OauthApplication from the given config.
func NewOauthApplicationClient(c config) *OauthApplicationClient {
	return &OauthApplicationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthapplication.Hooks(f(g(h())))`.
func (c *OauthApplicationClient) Use(hooks ...Hook) {
	c.hooks.OauthApplication = append(c.hooks.OauthApplication, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthapplication.Intercept(f(g(h())))`.
func (c *OauthApplicationClient) Intercept(interceptors ...Interceptor) {
	c.inters.OauthApplication = append(c.inters.OauthApplication, interceptors...)
}

// Create returns a builder for creating a OauthApplication entity.
func (c *OauthApplicationClient) Create() *OauthApplicationCreate {
	mutation := newOauthApplicationMutation(c.config, OpCreate)
	return &OauthApplicationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OauthApplication entities.
func (c *OauthApplicationClient) CreateBulk(builders ...*OauthApplicationCreate) *OauthApplicationCreateBulk {
	return &OauthApplicationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OauthApplicationClient) MapCreateBulk(slice any, setFunc func(*OauthApplicationCreate, int)) *OauthApplicationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OauthApplicationCreateBulk{err: fmt.Errorf("calling to OauthApplicationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OauthApplicationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OauthApplicationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OauthApplication.
func (c *OauthApplicationClient) Update() *OauthApplicationUpdate {
	mutation := newOauthApplicationMutation(c.config, OpUpdate)
	return &OauthApplicationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OauthApplicationClient) UpdateOne(_m *OauthApplication) *OauthApplicationUpdateOne {
	mutation := newOauthApplicationMutation(c.config, OpUpdateOne, withOauthApplication(_m))
	return &OauthApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OauthApplicationClient) UpdateOneID(id uint64) *OauthApplicationUpdateOne {
	mutation := newOauthApplicationMutation(c.config, OpUpdateOne, withOauthApplicationID(id))
	return &OauthApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OauthApplication.
func (c *OauthApplicationClient) Delete() *OauthApplicationDelete {
	mutation := newOauthApplicationMutation(c.config, OpDelete)
	return &OauthApplicationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OauthApplicationClient) DeleteOne(_m *OauthApplication) *OauthApplicationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OauthApplicationClient) DeleteOneID(id uint64) *OauthApplicationDeleteOne {
	builder := c.Delete().Where(oauthapplication.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OauthApplicationDeleteOne{builder}
}

// Query returns a query builder for OauthApplication.
func (c *OauthApplicationClient) Query() *OauthApplicationQuery {
	return &OauthApplicationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOauthApplication},
		inters: c.Interceptors(),
	}
}

// Get returns a OauthApplication entity by its id.
func (c *OauthApplicationClient) Get(ctx context.Context, id uint64) (*OauthApplication, error) {
	return c.Query().Where(oauthapplication.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OauthApplicationClient) GetX(ctx context.Context, id uint64) *OauthApplication {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthorizationCodes queries the authorization_codes edge of a OauthApplication.
func (c *OauthApplicationClient) QueryAuthorizationCodes(_m *OauthApplication) *OauthAuthorizationCodeQuery {
	query := (&OauthAuthorizationCodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthapplication.Table, oauthapplication.FieldID, id),
			sqlgraph.To(oauthauthorizationcode.Table, oauthauthorizationcode.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oauthapplication.AuthorizationCodesTable, oauthapplication.AuthorizationCodesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTokens queries the tokens edge of a OauthApplication.
func (c *OauthApplicationClient) QueryTokens(_m *OauthApplication) *OauthTokenQuery {
	query := (&OauthTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthapplication.Table, oauthapplication.FieldID, id),
			sqlgraph.To(oauthtoken.Table, oauthtoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oauthapplication.TokensTable, oauthapplication.TokensColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserAuthorizations queries the user_authorizations edge of a OauthApplication.
func (c *OauthApplicationClient) QueryUserAuthorizations(_m *OauthApplication) *OauthUserAuthorizationQuery {
	query := (&OauthUserAuthorizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthapplication.Table, oauthapplication.FieldID, id),
			sqlgraph.To(oauthuserauthorization.Table, oauthuserauthorization.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oauthapplication.UserAuthorizationsTable, oauthapplication.UserAuthorizationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OauthApplicationClient) Hooks() []Hook {
	hooks := c.hooks.OauthApplication
	return append(hooks[:len(hooks):len(hooks)], oauthapplication.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OauthApplicationClient) Interceptors() []Interceptor {
	inters := c.inters.OauthApplication
	return append(inters[:len(inters):len(inters)], oauthapplication.Interceptors[:]...)
}

func (c *OauthApplicationClient) mutate(ctx context.Context, m *OauthApplicationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OauthApplicationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OauthApplicationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OauthApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OauthApplicationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OauthApplication mutation op: %q", m.Op())
	}
}

// OauthAuthorizationCodeClient is a client for the OauthAuthorizationCode schema.
type OauthAuthorizationCodeClient struct {
	config
}

// NewOauthAuthorizationCodeClient returns a client for the OauthAuthorizationCode from the given config.
func NewOauthAuthorizationCodeClient(c config) *OauthAuthorizationCodeClient {
	return &OauthAuthorizationCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthauthorizationcode.Hooks(f(g(h())))`.
func (c *OauthAuthorizationCodeClient) Use(hooks ...Hook) {
	c.hooks.OauthAuthorizationCode = append(c.hooks.OauthAuthorizationCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthauthorizationcode.Intercept(f(g(h())))`.
func (c *OauthAuthorizationCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.OauthAuthorizationCode = append(c.inters.OauthAuthorizationCode, interceptors...)
}

// Create returns a builder for creating a OauthAuthorizationCode entity.
func (c *OauthAuthorizationCodeClient) Create() *OauthAuthorizationCodeCreate {
	mutation := newOauthAuthorizationCodeMutation(c.config, OpCreate)
	return &OauthAuthorizationCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OauthAuthorizationCode entities.
func (c *OauthAuthorizationCodeClient) CreateBulk(builders ...*OauthAuthorizationCodeCreate) *OauthAuthorizationCodeCreateBulk {
	return &OauthAuthorizationCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OauthAuthorizationCodeClient) MapCreateBulk(slice any, setFunc func(*OauthAuthorizationCodeCreate, int)) *OauthAuthorizationCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OauthAuthorizationCodeCreateBulk{err: fmt.Errorf("calling to OauthAuthorizationCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OauthAuthorizationCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OauthAuthorizationCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OauthAuthorizationCode.
func (c *OauthAuthorizationCodeClient) Update() *OauthAuthorizationCodeUpdate {
	mutation := newOauthAuthorizationCodeMutation(c.config, OpUpdate)
	return &OauthAuthorizationCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OauthAuthorizationCodeClient) UpdateOne(_m *OauthAuthorizationCode) *OauthAuthorizationCodeUpdateOne {
	mutation := newOauthAuthorizationCodeMutation(c.config, OpUpdateOne, withOauthAuthorizationCode(_m))
	return &OauthAuthorizationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OauthAuthorizationCodeClient) UpdateOneID(id uint64) *OauthAuthorizationCodeUpdateOne {
	mutation := newOauthAuthorizationCodeMutation(c.config, OpUpdateOne, withOauthAuthorizationCodeID(id))
	return &OauthAuthorizationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OauthAuthorizationCode.
func (c *OauthAuthorizationCodeClient) Delete() *OauthAuthorizationCodeDelete {
	mutation := newOauthAuthorizationCodeMutation(c.config, OpDelete)
	return &OauthAuthorizationCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OauthAuthorizationCodeClient) DeleteOne(_m *OauthAuthorizationCode) *OauthAuthorizationCodeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OauthAuthorizationCodeClient) DeleteOneID(id uint64) *OauthAuthorizationCodeDeleteOne {
	builder := c.Delete().Where(oauthauthorizationcode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OauthAuthorizationCodeDeleteOne{builder}
}

// Query returns a query builder for OauthAuthorizationCode.
func (c *OauthAuthorizationCodeClient) Query() *OauthAuthorizationCodeQuery {
	return &OauthAuthorizationCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOauthAuthorizationCode},
		inters: c.Interceptors(),
	}
}

// Get returns a OauthAuthorizationCode entity by its id.
func (c *OauthAuthorizationCodeClient) Get(ctx context.Context, id uint64) (*OauthAuthorizationCode, error) {
	return c.Query().Where(oauthauthorizationcode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OauthAuthorizationCodeClient) GetX(ctx context.Context, id uint64) *OauthAuthorizationCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApplication queries the application edge of a OauthAuthorizationCode.
func (c *OauthAuthorizationCodeClient) QueryApplication(_m *OauthAuthorizationCode) *OauthApplicationQuery {
	query := (&OauthApplicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthauthorizationcode.Table, oauthauthorizationcode.FieldID, id),
			sqlgraph.To(oauthapplication.Table, oauthapplication.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oauthauthorizationcode.ApplicationTable, oauthauthorizationcode.ApplicationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a OauthAuthorizationCode.
func (c *OauthAuthorizationCodeClient) QueryUser(_m *OauthAuthorizationCode) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthauthorizationcode.Table, oauthauthorizationcode.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oauthauthorizationcode.UserTable, oauthauthorizationcode.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryToken queries the token edge of a OauthAuthorizationCode.
func (c *OauthAuthorizationCodeClient) QueryToken(_m *OauthAuthorizationCode) *OauthTokenQuery {
	query := (&OauthTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthauthorizationcode.Table, oauthauthorizationcode.FieldID, id),
			sqlgraph.To(oauthtoken.Table, oauthtoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, oauthauthorizationcode.TokenTable, oauthauthorizationcode.TokenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserAuthorization queries the user_authorization edge of a OauthAuthorizationCode.
func (c *OauthAuthorizationCodeClient) QueryUserAuthorization(_m *OauthAuthorizationCode) *OauthUserAuthorizationQuery {
	query := (&OauthUserAuthorizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthauthorizationcode.Table, oauthauthorizationcode.FieldID, id),
			sqlgraph.To(oauthuserauthorization.Table, oauthuserauthorization.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, oauthauthorizationcode.UserAuthorizationTable, oauthauthorizationcode.UserAuthorizationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OauthAuthorizationCodeClient) Hooks() []Hook {
	hooks := c.hooks.OauthAuthorizationCode
	return append(hooks[:len(hooks):len(hooks)], oauthauthorizationcode.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OauthAuthorizationCodeClient) Interceptors() []Interceptor {
	inters := c.inters.OauthAuthorizationCode
	return append(inters[:len(inters):len(inters)], oauthauthorizationcode.Interceptors[:]...)
}

func (c *OauthAuthorizationCodeClient) mutate(ctx context.Context, m *OauthAuthorizationCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OauthAuthorizationCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OauthAuthorizationCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OauthAuthorizationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OauthAuthorizationCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OauthAuthorizationCode mutation op: %q", m.Op())
	}
}

// OauthProviderClient is a client for the OauthProvider schema.
type OauthProviderClient struct {
	config
}

// NewOauthProviderClient returns a client for the OauthProvider from the given config.
func NewOauthProviderClient(c config) *OauthProviderClient {
	return &OauthProviderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthprovider.Hooks(f(g(h())))`.
func (c *OauthProviderClient) Use(hooks ...Hook) {
	c.hooks.OauthProvider = append(c.hooks.OauthProvider, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthprovider.Intercept(f(g(h())))`.
func (c *OauthProviderClient) Intercept(interceptors ...Interceptor) {
	c.inters.OauthProvider = append(c.inters.OauthProvider, interceptors...)
}

// Create returns a builder for creating a OauthProvider entity.
func (c *OauthProviderClient) Create() *OauthProviderCreate {
	mutation := newOauthProviderMutation(c.config, OpCreate)
	return &OauthProviderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OauthProvider entities.
func (c *OauthProviderClient) CreateBulk(builders ...*OauthProviderCreate) *OauthProviderCreateBulk {
	return &OauthProviderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OauthProviderClient) MapCreateBulk(slice any, setFunc func(*OauthProviderCreate, int)) *OauthProviderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OauthProviderCreateBulk{err: fmt.Errorf("calling to OauthProviderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OauthProviderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OauthProviderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OauthProvider.
func (c *OauthProviderClient) Update() *OauthProviderUpdate {
	mutation := newOauthProviderMutation(c.config, OpUpdate)
	return &OauthProviderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OauthProviderClient) UpdateOne(_m *OauthProvider) *OauthProviderUpdateOne {
	mutation := newOauthProviderMutation(c.config, OpUpdateOne, withOauthProvider(_m))
	return &OauthProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OauthProviderClient) UpdateOneID(id uint64) *OauthProviderUpdateOne {
	mutation := newOauthProviderMutation(c.config, OpUpdateOne, withOauthProviderID(id))
	return &OauthProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OauthProvider.
func (c *OauthProviderClient) Delete() *OauthProviderDelete {
	mutation := newOauthProviderMutation(c.config, OpDelete)
	return &OauthProviderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OauthProviderClient) DeleteOne(_m *OauthProvider) *OauthProviderDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OauthProviderClient) DeleteOneID(id uint64) *OauthProviderDeleteOne {
	builder := c.Delete().Where(oauthprovider.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OauthProviderDeleteOne{builder}
}

// Query returns a query builder for OauthProvider.
func (c *OauthProviderClient) Query() *OauthProviderQuery {
	return &OauthProviderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOauthProvider},
		inters: c.Interceptors(),
	}
}

// Get returns a OauthProvider entity by its id.
func (c *OauthProviderClient) Get(ctx context.Context, id uint64) (*OauthProvider, error) {
	return c.Query().Where(oauthprovider.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OauthProviderClient) GetX(ctx context.Context, id uint64) *OauthProvider {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStates queries the states edge of a OauthProvider.
func (c *OauthProviderClient) QueryStates(_m *OauthProvider) *OauthStateQuery {
	query := (&OauthStateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthprovider.Table, oauthprovider.FieldID, id),
			sqlgraph.To(oauthstate.Table, oauthstate.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oauthprovider.StatesTable, oauthprovider.StatesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOauthUsers queries the oauth_users edge of a OauthProvider.
func (c *OauthProviderClient) QueryOauthUsers(_m *OauthProvider) *OauthUserQuery {
	query := (&OauthUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthprovider.Table, oauthprovider.FieldID, id),
			sqlgraph.To(oauthuser.Table, oauthuser.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oauthprovider.OauthUsersTable, oauthprovider.OauthUsersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OauthProviderClient) Hooks() []Hook {
	hooks := c.hooks.OauthProvider
	return append(hooks[:len(hooks):len(hooks)], oauthprovider.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OauthProviderClient) Interceptors() []Interceptor {
	inters := c.inters.OauthProvider
	return append(inters[:len(inters):len(inters)], oauthprovider.Interceptors[:]...)
}

func (c *OauthProviderClient) mutate(ctx context.Context, m *OauthProviderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OauthProviderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OauthProviderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OauthProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OauthProviderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OauthProvider mutation op: %q", m.Op())
	}
}

// OauthStateClient is a client for the OauthState schema.
type OauthStateClient struct {
	config
}

// NewOauthStateClient returns a client for the OauthState from the given config.
func NewOauthStateClient(c config) *OauthStateClient {
	return &OauthStateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthstate.Hooks(f(g(h())))`.
func (c *OauthStateClient) Use(hooks ...Hook) {
	c.hooks.OauthState = append(c.hooks.OauthState, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthstate.Intercept(f(g(h())))`.
func (c *OauthStateClient) Intercept(interceptors ...Interceptor) {
	c.inters.OauthState = append(c.inters.OauthState, interceptors...)
}

// Create returns a builder for creating a OauthState entity.
func (c *OauthStateClient) Create() *OauthStateCreate {
	mutation := newOauthStateMutation(c.config, OpCreate)
	return &OauthStateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OauthState entities.
func (c *OauthStateClient) CreateBulk(builders ...*OauthStateCreate) *OauthStateCreateBulk {
	return &OauthStateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OauthStateClient) MapCreateBulk(slice any, setFunc func(*OauthStateCreate, int)) *OauthStateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OauthStateCreateBulk{err: fmt.Errorf("calling to OauthStateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OauthStateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OauthStateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OauthState.
func (c *OauthStateClient) Update() *OauthStateUpdate {
	mutation := newOauthStateMutation(c.config, OpUpdate)
	return &OauthStateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OauthStateClient) UpdateOne(_m *OauthState) *OauthStateUpdateOne {
	mutation := newOauthStateMutation(c.config, OpUpdateOne, withOauthState(_m))
	return &OauthStateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OauthStateClient) UpdateOneID(id uint64) *OauthStateUpdateOne {
	mutation := newOauthStateMutation(c.config, OpUpdateOne, withOauthStateID(id))
	return &OauthStateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OauthState.
func (c *OauthStateClient) Delete() *OauthStateDelete {
	mutation := newOauthStateMutation(c.config, OpDelete)
	return &OauthStateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OauthStateClient) DeleteOne(_m *OauthState) *OauthStateDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OauthStateClient) DeleteOneID(id uint64) *OauthStateDeleteOne {
	builder := c.Delete().Where(oauthstate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OauthStateDeleteOne{builder}
}

// Query returns a query builder for OauthState.
func (c *OauthStateClient) Query() *OauthStateQuery {
	return &OauthStateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOauthState},
		inters: c.Interceptors(),
	}
}

// Get returns a OauthState entity by its id.
func (c *OauthStateClient) Get(ctx context.Context, id uint64) (*OauthState, error) {
	return c.Query().Where(oauthstate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OauthStateClient) GetX(ctx context.Context, id uint64) *OauthState {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProvider queries the provider edge of a OauthState.
func (c *OauthStateClient) QueryProvider(_m *OauthState) *OauthProviderQuery {
	query := (&OauthProviderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthstate.Table, oauthstate.FieldID, id),
			sqlgraph.To(oauthprovider.Table, oauthprovider.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oauthstate.ProviderTable, oauthstate.ProviderColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a OauthState.
func (c *OauthStateClient) QueryUser(_m *OauthState) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthstate.Table, oauthstate.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oauthstate.UserTable, oauthstate.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOauthUsers queries the oauth_users edge of a OauthState.
func (c *OauthStateClient) QueryOauthUsers(_m *OauthState) *OauthUserQuery {
	query := (&OauthUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthstate.Table, oauthstate.FieldID, id),
			sqlgraph.To(oauthuser.Table, oauthuser.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oauthstate.OauthUsersTable, oauthstate.OauthUsersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OauthStateClient) Hooks() []Hook {
	hooks := c.hooks.OauthState
	return append(hooks[:len(hooks):len(hooks)], oauthstate.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OauthStateClient) Interceptors() []Interceptor {
	inters := c.inters.OauthState
	return append(inters[:len(inters):len(inters)], oauthstate.Interceptors[:]...)
}

func (c *OauthStateClient) mutate(ctx context.Context, m *OauthStateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OauthStateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OauthStateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OauthStateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OauthStateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OauthState mutation op: %q", m.Op())
	}
}

// OauthTokenClient is a client for the OauthToken schema.
type OauthTokenClient struct {
	config
}

// NewOauthTokenClient returns a client for the OauthToken from the given config.
func NewOauthTokenClient(c config) *OauthTokenClient {
	return &OauthTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthtoken.Hooks(f(g(h())))`.
func (c *OauthTokenClient) Use(hooks ...Hook) {
	c.hooks.OauthToken = append(c.hooks.OauthToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthtoken.Intercept(f(g(h())))`.
func (c *OauthTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.OauthToken = append(c.inters.OauthToken, interceptors...)
}

// Create returns a builder for creating a OauthToken entity.
func (c *OauthTokenClient) Create() *OauthTokenCreate {
	mutation := newOauthTokenMutation(c.config, OpCreate)
	return &OauthTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OauthToken entities.
func (c *OauthTokenClient) CreateBulk(builders ...*OauthTokenCreate) *OauthTokenCreateBulk {
	return &OauthTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OauthTokenClient) MapCreateBulk(slice any, setFunc func(*OauthTokenCreate, int)) *OauthTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OauthTokenCreateBulk{err: fmt.Errorf("calling to OauthTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OauthTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OauthTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OauthToken.
func (c *OauthTokenClient) Update() *OauthTokenUpdate {
	mutation := newOauthTokenMutation(c.config, OpUpdate)
	return &OauthTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OauthTokenClient) UpdateOne(_m *OauthToken) *OauthTokenUpdateOne {
	mutation := newOauthTokenMutation(c.config, OpUpdateOne, withOauthToken(_m))
	return &OauthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OauthTokenClient) UpdateOneID(id uint64) *OauthTokenUpdateOne {
	mutation := newOauthTokenMutation(c.config, OpUpdateOne, withOauthTokenID(id))
	return &OauthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OauthToken.
func (c *OauthTokenClient) Delete() *OauthTokenDelete {
	mutation := newOauthTokenMutation(c.config, OpDelete)
	return &OauthTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OauthTokenClient) DeleteOne(_m *OauthToken) *OauthTokenDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OauthTokenClient) DeleteOneID(id uint64) *OauthTokenDeleteOne {
	builder := c.Delete().Where(oauthtoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OauthTokenDeleteOne{builder}
}

// Query returns a query builder for OauthToken.
func (c *OauthTokenClient) Query() *OauthTokenQuery {
	return &OauthTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOauthToken},
		inters: c.Interceptors(),
	}
}

// Get returns a OauthToken entity by its id.
func (c *OauthTokenClient) Get(ctx context.Context, id uint64) (*OauthToken, error) {
	return c.Query().Where(oauthtoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OauthTokenClient) GetX(ctx context.Context, id uint64) *OauthToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApplication queries the application edge of a OauthToken.
func (c *OauthTokenClient) QueryApplication(_m *OauthToken) *OauthApplicationQuery {
	query := (&OauthApplicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthtoken.Table, oauthtoken.FieldID, id),
			sqlgraph.To(oauthapplication.Table, oauthapplication.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oauthtoken.ApplicationTable, oauthtoken.ApplicationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a OauthToken.
func (c *OauthTokenClient) QueryUser(_m *OauthToken) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthtoken.Table, oauthtoken.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oauthtoken.UserTable, oauthtoken.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthorizationCode queries the authorization_code edge of a OauthToken.
func (c *OauthTokenClient) QueryAuthorizationCode(_m *OauthToken) *OauthAuthorizationCodeQuery {
	query := (&OauthAuthorizationCodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthtoken.Table, oauthtoken.FieldID, id),
			sqlgraph.To(oauthauthorizationcode.Table, oauthauthorizationcode.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, oauthtoken.AuthorizationCodeTable, oauthtoken.AuthorizationCodeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserAuthorization queries the user_authorization edge of a OauthToken.
func (c *OauthTokenClient) QueryUserAuthorization(_m *OauthToken) *OauthUserAuthorizationQuery {
	query := (&OauthUserAuthorizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthtoken.Table, oauthtoken.FieldID, id),
			sqlgraph.To(oauthuserauthorization.Table, oauthuserauthorization.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, oauthtoken.UserAuthorizationTable, oauthtoken.UserAuthorizationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OauthTokenClient) Hooks() []Hook {
	hooks := c.hooks.OauthToken
	return append(hooks[:len(hooks):len(hooks)], oauthtoken.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OauthTokenClient) Interceptors() []Interceptor {
	inters := c.inters.OauthToken
	return append(inters[:len(inters):len(inters)], oauthtoken.Interceptors[:]...)
}

func (c *OauthTokenClient) mutate(ctx context.Context, m *OauthTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OauthTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OauthTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OauthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OauthTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OauthToken mutation op: %q", m.Op())
	}
}

// OauthUserClient is a client for the OauthUser schema.
type OauthUserClient struct {
	config
}

// NewOauthUserClient returns a client for the OauthUser from the given config.
func NewOauthUserClient(c config) *OauthUserClient {
	return &OauthUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthuser.Hooks(f(g(h())))`.
func (c *OauthUserClient) Use(hooks ...Hook) {
	c.hooks.OauthUser = append(c.hooks.OauthUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthuser.Intercept(f(g(h())))`.
func (c *OauthUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.OauthUser = append(c.inters.OauthUser, interceptors...)
}

// Create returns a builder for creating a OauthUser entity.
func (c *OauthUserClient) Create() *OauthUserCreate {
	mutation := newOauthUserMutation(c.config, OpCreate)
	return &OauthUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OauthUser entities.
func (c *OauthUserClient) CreateBulk(builders ...*OauthUserCreate) *OauthUserCreateBulk {
	return &OauthUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OauthUserClient) MapCreateBulk(slice any, setFunc func(*OauthUserCreate, int)) *OauthUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OauthUserCreateBulk{err: fmt.Errorf("calling to OauthUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OauthUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OauthUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OauthUser.
func (c *OauthUserClient) Update() *OauthUserUpdate {
	mutation := newOauthUserMutation(c.config, OpUpdate)
	return &OauthUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OauthUserClient) UpdateOne(_m *OauthUser) *OauthUserUpdateOne {
	mutation := newOauthUserMutation(c.config, OpUpdateOne, withOauthUser(_m))
	return &OauthUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OauthUserClient) UpdateOneID(id uint64) *OauthUserUpdateOne {
	mutation := newOauthUserMutation(c.config, OpUpdateOne, withOauthUserID(id))
	return &OauthUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OauthUser.
func (c *OauthUserClient) Delete() *OauthUserDelete {
	mutation := newOauthUserMutation(c.config, OpDelete)
	return &OauthUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OauthUserClient) DeleteOne(_m *OauthUser) *OauthUserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OauthUserClient) DeleteOneID(id uint64) *OauthUserDeleteOne {
	builder := c.Delete().Where(oauthuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OauthUserDeleteOne{builder}
}

// Query returns a query builder for OauthUser.
func (c *OauthUserClient) Query() *OauthUserQuery {
	return &OauthUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOauthUser},
		inters: c.Interceptors(),
	}
}

// Get returns a OauthUser entity by its id.
func (c *OauthUserClient) Get(ctx context.Context, id uint64) (*OauthUser, error) {
	return c.Query().Where(oauthuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OauthUserClient) GetX(ctx context.Context, id uint64) *OauthUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProvider queries the provider edge of a OauthUser.
func (c *OauthUserClient) QueryProvider(_m *OauthUser) *OauthProviderQuery {
	query := (&OauthProviderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthuser.Table, oauthuser.FieldID, id),
			sqlgraph.To(oauthprovider.Table, oauthprovider.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oauthuser.ProviderTable, oauthuser.ProviderColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a OauthUser.
func (c *OauthUserClient) QueryUser(_m *OauthUser) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthuser.Table, oauthuser.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oauthuser.UserTable, oauthuser.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryState queries the state edge of a OauthUser.
func (c *OauthUserClient) QueryState(_m *OauthUser) *OauthStateQuery {
	query := (&OauthStateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthuser.Table, oauthuser.FieldID, id),
			sqlgraph.To(oauthstate.Table, oauthstate.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oauthuser.StateTable, oauthuser.StateColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OauthUserClient) Hooks() []Hook {
	hooks := c.hooks.OauthUser
	return append(hooks[:len(hooks):len(hooks)], oauthuser.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OauthUserClient) Interceptors() []Interceptor {
	inters := c.inters.OauthUser
	return append(inters[:len(inters):len(inters)], oauthuser.Interceptors[:]...)
}

func (c *OauthUserClient) mutate(ctx context.Context, m *OauthUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OauthUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OauthUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OauthUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OauthUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OauthUser mutation op: %q", m.Op())
	}
}

// OauthUserAuthorizationClient is a client for the OauthUserAuthorization schema.
type OauthUserAuthorizationClient struct {
	config
}

// NewOauthUserAuthorizationClient returns a client for the OauthUserAuthorization from the given config.
func NewOauthUserAuthorizationClient(c config) *OauthUserAuthorizationClient {
	return &OauthUserAuthorizationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthuserauthorization.Hooks(f(g(h())))`.
func (c *OauthUserAuthorizationClient) Use(hooks ...Hook) {
	c.hooks.OauthUserAuthorization = append(c.hooks.OauthUserAuthorization, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthuserauthorization.Intercept(f(g(h())))`.
func (c *OauthUserAuthorizationClient) Intercept(interceptors ...Interceptor) {
	c.inters.OauthUserAuthorization = append(c.inters.OauthUserAuthorization, interceptors...)
}

// Create returns a builder for creating a OauthUserAuthorization entity.
func (c *OauthUserAuthorizationClient) Create() *OauthUserAuthorizationCreate {
	mutation := newOauthUserAuthorizationMutation(c.config, OpCreate)
	return &OauthUserAuthorizationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OauthUserAuthorization entities.
func (c *OauthUserAuthorizationClient) CreateBulk(builders ...*OauthUserAuthorizationCreate) *OauthUserAuthorizationCreateBulk {
	return &OauthUserAuthorizationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OauthUserAuthorizationClient) MapCreateBulk(slice any, setFunc func(*OauthUserAuthorizationCreate, int)) *OauthUserAuthorizationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OauthUserAuthorizationCreateBulk{err: fmt.Errorf("calling to OauthUserAuthorizationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OauthUserAuthorizationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OauthUserAuthorizationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OauthUserAuthorization.
func (c *OauthUserAuthorizationClient) Update() *OauthUserAuthorizationUpdate {
	mutation := newOauthUserAuthorizationMutation(c.config, OpUpdate)
	return &OauthUserAuthorizationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OauthUserAuthorizationClient) UpdateOne(_m *OauthUserAuthorization) *OauthUserAuthorizationUpdateOne {
	mutation := newOauthUserAuthorizationMutation(c.config, OpUpdateOne, withOauthUserAuthorization(_m))
	return &OauthUserAuthorizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OauthUserAuthorizationClient) UpdateOneID(id uint64) *OauthUserAuthorizationUpdateOne {
	mutation := newOauthUserAuthorizationMutation(c.config, OpUpdateOne, withOauthUserAuthorizationID(id))
	return &OauthUserAuthorizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OauthUserAuthorization.
func (c *OauthUserAuthorizationClient) Delete() *OauthUserAuthorizationDelete {
	mutation := newOauthUserAuthorizationMutation(c.config, OpDelete)
	return &OauthUserAuthorizationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OauthUserAuthorizationClient) DeleteOne(_m *OauthUserAuthorization) *OauthUserAuthorizationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OauthUserAuthorizationClient) DeleteOneID(id uint64) *OauthUserAuthorizationDeleteOne {
	builder := c.Delete().Where(oauthuserauthorization.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OauthUserAuthorizationDeleteOne{builder}
}

// Query returns a query builder for OauthUserAuthorization.
func (c *OauthUserAuthorizationClient) Query() *OauthUserAuthorizationQuery {
	return &OauthUserAuthorizationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOauthUserAuthorization},
		inters: c.Interceptors(),
	}
}

// Get returns a OauthUserAuthorization entity by its id.
func (c *OauthUserAuthorizationClient) Get(ctx context.Context, id uint64) (*OauthUserAuthorization, error) {
	return c.Query().Where(oauthuserauthorization.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OauthUserAuthorizationClient) GetX(ctx context.Context, id uint64) *OauthUserAuthorization {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a OauthUserAuthorization.
func (c *OauthUserAuthorizationClient) QueryUser(_m *OauthUserAuthorization) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthuserauthorization.Table, oauthuserauthorization.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oauthuserauthorization.UserTable, oauthuserauthorization.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApplication queries the application edge of a OauthUserAuthorization.
func (c *OauthUserAuthorizationClient) QueryApplication(_m *OauthUserAuthorization) *OauthApplicationQuery {
	query := (&OauthApplicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthuserauthorization.Table, oauthuserauthorization.FieldID, id),
			sqlgraph.To(oauthapplication.Table, oauthapplication.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oauthuserauthorization.ApplicationTable, oauthuserauthorization.ApplicationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCode queries the code edge of a OauthUserAuthorization.
func (c *OauthUserAuthorizationClient) QueryCode(_m *OauthUserAuthorization) *OauthAuthorizationCodeQuery {
	query := (&OauthAuthorizationCodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthuserauthorization.Table, oauthuserauthorization.FieldID, id),
			sqlgraph.To(oauthauthorizationcode.Table, oauthauthorizationcode.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, oauthuserauthorization.CodeTable, oauthuserauthorization.CodeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryToken queries the token edge of a OauthUserAuthorization.
func (c *OauthUserAuthorizationClient) QueryToken(_m *OauthUserAuthorization) *OauthTokenQuery {
	query := (&OauthTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthuserauthorization.Table, oauthuserauthorization.FieldID, id),
			sqlgraph.To(oauthtoken.Table, oauthtoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, oauthuserauthorization.TokenTable, oauthuserauthorization.TokenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OauthUserAuthorizationClient) Hooks() []Hook {
	hooks := c.hooks.OauthUserAuthorization
	return append(hooks[:len(hooks):len(hooks)], oauthuserauthorization.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OauthUserAuthorizationClient) Interceptors() []Interceptor {
	inters := c.inters.OauthUserAuthorization
	return append(inters[:len(inters):len(inters)], oauthuserauthorization.Interceptors[:]...)
}

func (c *OauthUserAuthorizationClient) mutate(ctx context.Context, m *OauthUserAuthorizationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OauthUserAuthorizationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OauthUserAuthorizationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OauthUserAuthorizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OauthUserAuthorizationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OauthUserAuthorization mutation op: %q", m.Op())
	}
}

// PermissionClient is a client for the Permission schema.
type PermissionClient struct {
	config
}

// NewPermissionClient returns a client for the Permission from the given config.
func NewPermissionClient(c config) *PermissionClient {
	return &PermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `permission.Hooks(f(g(h())))`.
func (c *PermissionClient) Use(hooks ...Hook) {
	c.hooks.Permission = append(c.hooks.Permission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `permission.Intercept(f(g(h())))`.
func (c *PermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Permission = append(c.inters.Permission, interceptors...)
}

// Create returns a builder for creating a Permission entity.
func (c *PermissionClient) Create() *PermissionCreate {
	mutation := newPermissionMutation(c.config, OpCreate)
	return &PermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Permission entities.
func (c *PermissionClient) CreateBulk(builders ...*PermissionCreate) *PermissionCreateBulk {
	return &PermissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PermissionClient) MapCreateBulk(slice any, setFunc func(*PermissionCreate, int)) *PermissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PermissionCreateBulk{err: fmt.Errorf("calling to PermissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PermissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Permission.
func (c *PermissionClient) Update() *PermissionUpdate {
	mutation := newPermissionMutation(c.config, OpUpdate)
	return &PermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PermissionClient) UpdateOne(_m *Permission) *PermissionUpdateOne {
	mutation := newPermissionMutation(c.config, OpUpdateOne, withPermission(_m))
	return &PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PermissionClient) UpdateOneID(id uint64) *PermissionUpdateOne {
	mutation := newPermissionMutation(c.config, OpUpdateOne, withPermissionID(id))
	return &PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Permission.
func (c *PermissionClient) Delete() *PermissionDelete {
	mutation := newPermissionMutation(c.config, OpDelete)
	return &PermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PermissionClient) DeleteOne(_m *Permission) *PermissionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PermissionClient) DeleteOneID(id uint64) *PermissionDeleteOne {
	builder := c.Delete().Where(permission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PermissionDeleteOne{builder}
}

// Query returns a query builder for Permission.
func (c *PermissionClient) Query() *PermissionQuery {
	return &PermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePermission},
		inters: c.Interceptors(),
	}
}

// Get returns a Permission entity by its id.
func (c *PermissionClient) Get(ctx context.Context, id uint64) (*Permission, error) {
	return c.Query().Where(permission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PermissionClient) GetX(ctx context.Context, id uint64) *Permission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRolePermissions queries the role_permissions edge of a Permission.
func (c *PermissionClient) QueryRolePermissions(_m *Permission) *RolePermissionQuery {
	query := (&RolePermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(permission.Table, permission.FieldID, id),
			sqlgraph.To(rolepermission.Table, rolepermission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, permission.RolePermissionsTable, permission.RolePermissionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScope queries the scope edge of a Permission.
func (c *PermissionClient) QueryScope(_m *Permission) *ScopeQuery {
	query := (&ScopeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(permission.Table, permission.FieldID, id),
			sqlgraph.To(scope.Table, scope.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, permission.ScopeTable, permission.ScopeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAPIAuths queries the api_auths edge of a Permission.
func (c *PermissionClient) QueryAPIAuths(_m *Permission) *APIAuthQuery {
	query := (&APIAuthClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(permission.Table, permission.FieldID, id),
			sqlgraph.To(apiauth.Table, apiauth.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, permission.APIAuthsTable, permission.APIAuthsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PermissionClient) Hooks() []Hook {
	hooks := c.hooks.Permission
	return append(hooks[:len(hooks):len(hooks)], permission.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PermissionClient) Interceptors() []Interceptor {
	inters := c.inters.Permission
	return append(inters[:len(inters):len(inters)], permission.Interceptors[:]...)
}

func (c *PermissionClient) mutate(ctx context.Context, m *PermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Permission mutation op: %q", m.Op())
	}
}

// RoleClient is a client for the Role schema.
type RoleClient struct {
	config
}

// NewRoleClient returns a client for the Role from the given config.
func NewRoleClient(c config) *RoleClient {
	return &RoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role.Hooks(f(g(h())))`.
func (c *RoleClient) Use(hooks ...Hook) {
	c.hooks.Role = append(c.hooks.Role, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `role.Intercept(f(g(h())))`.
func (c *RoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Role = append(c.inters.Role, interceptors...)
}

// Create returns a builder for creating a Role entity.
func (c *RoleClient) Create() *RoleCreate {
	mutation := newRoleMutation(c.config, OpCreate)
	return &RoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Role entities.
func (c *RoleClient) CreateBulk(builders ...*RoleCreate) *RoleCreateBulk {
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoleClient) MapCreateBulk(slice any, setFunc func(*RoleCreate, int)) *RoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoleCreateBulk{err: fmt.Errorf("calling to RoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Role.
func (c *RoleClient) Update() *RoleUpdate {
	mutation := newRoleMutation(c.config, OpUpdate)
	return &RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleClient) UpdateOne(_m *Role) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRole(_m))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleClient) UpdateOneID(id uint64) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRoleID(id))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role.
func (c *RoleClient) Delete() *RoleDelete {
	mutation := newRoleMutation(c.config, OpDelete)
	return &RoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleClient) DeleteOne(_m *Role) *RoleDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleClient) DeleteOneID(id uint64) *RoleDeleteOne {
	builder := c.Delete().Where(role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleDeleteOne{builder}
}

// Query returns a query builder for Role.
func (c *RoleClient) Query() *RoleQuery {
	return &RoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRole},
		inters: c.Interceptors(),
	}
}

// Get returns a Role entity by its id.
func (c *RoleClient) Get(ctx context.Context, id uint64) (*Role, error) {
	return c.Query().Where(role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleClient) GetX(ctx context.Context, id uint64) *Role {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserRoles queries the user_roles edge of a Role.
func (c *RoleClient) QueryUserRoles(_m *Role) *UserRoleQuery {
	query := (&UserRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(userrole.Table, userrole.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, role.UserRolesTable, role.UserRolesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRolePermissions queries the role_permissions edge of a Role.
func (c *RoleClient) QueryRolePermissions(_m *Role) *RolePermissionQuery {
	query := (&RolePermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(rolepermission.Table, rolepermission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, role.RolePermissionsTable, role.RolePermissionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInheritedBy queries the inherited_by edge of a Role.
func (c *RoleClient) QueryInheritedBy(_m *Role) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, role.InheritedByTable, role.InheritedByPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInheritsFrom queries the inherits_from edge of a Role.
func (c *RoleClient) QueryInheritsFrom(_m *Role) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, role.InheritsFromTable, role.InheritsFromPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClientDevice queries the client_device edge of a Role.
func (c *RoleClient) QueryClientDevice(_m *Role) *ClientDeviceQuery {
	query := (&ClientDeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(clientdevice.Table, clientdevice.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, role.ClientDeviceTable, role.ClientDevicePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoleClient) Hooks() []Hook {
	hooks := c.hooks.Role
	return append(hooks[:len(hooks):len(hooks)], role.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RoleClient) Interceptors() []Interceptor {
	inters := c.inters.Role
	return append(inters[:len(inters):len(inters)], role.Interceptors[:]...)
}

func (c *RoleClient) mutate(ctx context.Context, m *RoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Role mutation op: %q", m.Op())
	}
}

// RolePermissionClient is a client for the RolePermission schema.
type RolePermissionClient struct {
	config
}

// NewRolePermissionClient returns a client for the RolePermission from the given config.
func NewRolePermissionClient(c config) *RolePermissionClient {
	return &RolePermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rolepermission.Hooks(f(g(h())))`.
func (c *RolePermissionClient) Use(hooks ...Hook) {
	c.hooks.RolePermission = append(c.hooks.RolePermission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rolepermission.Intercept(f(g(h())))`.
func (c *RolePermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.RolePermission = append(c.inters.RolePermission, interceptors...)
}

// Create returns a builder for creating a RolePermission entity.
func (c *RolePermissionClient) Create() *RolePermissionCreate {
	mutation := newRolePermissionMutation(c.config, OpCreate)
	return &RolePermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RolePermission entities.
func (c *RolePermissionClient) CreateBulk(builders ...*RolePermissionCreate) *RolePermissionCreateBulk {
	return &RolePermissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RolePermissionClient) MapCreateBulk(slice any, setFunc func(*RolePermissionCreate, int)) *RolePermissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RolePermissionCreateBulk{err: fmt.Errorf("calling to RolePermissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RolePermissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RolePermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RolePermission.
func (c *RolePermissionClient) Update() *RolePermissionUpdate {
	mutation := newRolePermissionMutation(c.config, OpUpdate)
	return &RolePermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RolePermissionClient) UpdateOne(_m *RolePermission) *RolePermissionUpdateOne {
	mutation := newRolePermissionMutation(c.config, OpUpdateOne, withRolePermission(_m))
	return &RolePermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RolePermissionClient) UpdateOneID(id uint64) *RolePermissionUpdateOne {
	mutation := newRolePermissionMutation(c.config, OpUpdateOne, withRolePermissionID(id))
	return &RolePermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RolePermission.
func (c *RolePermissionClient) Delete() *RolePermissionDelete {
	mutation := newRolePermissionMutation(c.config, OpDelete)
	return &RolePermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RolePermissionClient) DeleteOne(_m *RolePermission) *RolePermissionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RolePermissionClient) DeleteOneID(id uint64) *RolePermissionDeleteOne {
	builder := c.Delete().Where(rolepermission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RolePermissionDeleteOne{builder}
}

// Query returns a query builder for RolePermission.
func (c *RolePermissionClient) Query() *RolePermissionQuery {
	return &RolePermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRolePermission},
		inters: c.Interceptors(),
	}
}

// Get returns a RolePermission entity by its id.
func (c *RolePermissionClient) Get(ctx context.Context, id uint64) (*RolePermission, error) {
	return c.Query().Where(rolepermission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RolePermissionClient) GetX(ctx context.Context, id uint64) *RolePermission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRole queries the role edge of a RolePermission.
func (c *RolePermissionClient) QueryRole(_m *RolePermission) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rolepermission.Table, rolepermission.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, rolepermission.RoleTable, rolepermission.RoleColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPermission queries the permission edge of a RolePermission.
func (c *RolePermissionClient) QueryPermission(_m *RolePermission) *PermissionQuery {
	query := (&PermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rolepermission.Table, rolepermission.FieldID, id),
			sqlgraph.To(permission.Table, permission.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, rolepermission.PermissionTable, rolepermission.PermissionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RolePermissionClient) Hooks() []Hook {
	hooks := c.hooks.RolePermission
	return append(hooks[:len(hooks):len(hooks)], rolepermission.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RolePermissionClient) Interceptors() []Interceptor {
	inters := c.inters.RolePermission
	return append(inters[:len(inters):len(inters)], rolepermission.Interceptors[:]...)
}

func (c *RolePermissionClient) mutate(ctx context.Context, m *RolePermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RolePermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RolePermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RolePermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RolePermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RolePermission mutation op: %q", m.Op())
	}
}

// ScanClient is a client for the Scan schema.
type ScanClient struct {
	config
}

// NewScanClient returns a client for the Scan from the given config.
func NewScanClient(c config) *ScanClient {
	return &ScanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scan.Hooks(f(g(h())))`.
func (c *ScanClient) Use(hooks ...Hook) {
	c.hooks.Scan = append(c.hooks.Scan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scan.Intercept(f(g(h())))`.
func (c *ScanClient) Intercept(interceptors ...Interceptor) {
	c.inters.Scan = append(c.inters.Scan, interceptors...)
}

// Create returns a builder for creating a Scan entity.
func (c *ScanClient) Create() *ScanCreate {
	mutation := newScanMutation(c.config, OpCreate)
	return &ScanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Scan entities.
func (c *ScanClient) CreateBulk(builders ...*ScanCreate) *ScanCreateBulk {
	return &ScanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScanClient) MapCreateBulk(slice any, setFunc func(*ScanCreate, int)) *ScanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScanCreateBulk{err: fmt.Errorf("calling to ScanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Scan.
func (c *ScanClient) Update() *ScanUpdate {
	mutation := newScanMutation(c.config, OpUpdate)
	return &ScanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScanClient) UpdateOne(_m *Scan) *ScanUpdateOne {
	mutation := newScanMutation(c.config, OpUpdateOne, withScan(_m))
	return &ScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScanClient) UpdateOneID(id uint64) *ScanUpdateOne {
	mutation := newScanMutation(c.config, OpUpdateOne, withScanID(id))
	return &ScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Scan.
func (c *ScanClient) Delete() *ScanDelete {
	mutation := newScanMutation(c.config, OpDelete)
	return &ScanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScanClient) DeleteOne(_m *Scan) *ScanDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScanClient) DeleteOneID(id uint64) *ScanDeleteOne {
	builder := c.Delete().Where(scan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScanDeleteOne{builder}
}

// Query returns a query builder for Scan.
func (c *ScanClient) Query() *ScanQuery {
	return &ScanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScan},
		inters: c.Interceptors(),
	}
}

// Get returns a Scan entity by its id.
func (c *ScanClient) Get(ctx context.Context, id uint64) (*Scan, error) {
	return c.Query().Where(scan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScanClient) GetX(ctx context.Context, id uint64) *Scan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAttachment queries the attachment edge of a Scan.
func (c *ScanClient) QueryAttachment(_m *Scan) *AttachmentQuery {
	query := (&AttachmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scan.Table, scan.FieldID, id),
			sqlgraph.To(attachment.Table, attachment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, scan.AttachmentTable, scan.AttachmentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScanClient) Hooks() []Hook {
	hooks := c.hooks.Scan
	return append(hooks[:len(hooks):len(hooks)], scan.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ScanClient) Interceptors() []Interceptor {
	inters := c.inters.Scan
	return append(inters[:len(inters):len(inters)], scan.Interceptors[:]...)
}

func (c *ScanClient) mutate(ctx context.Context, m *ScanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Scan mutation op: %q", m.Op())
	}
}

// ScopeClient is a client for the Scope schema.
type ScopeClient struct {
	config
}

// NewScopeClient returns a client for the Scope from the given config.
func NewScopeClient(c config) *ScopeClient {
	return &ScopeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scope.Hooks(f(g(h())))`.
func (c *ScopeClient) Use(hooks ...Hook) {
	c.hooks.Scope = append(c.hooks.Scope, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scope.Intercept(f(g(h())))`.
func (c *ScopeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Scope = append(c.inters.Scope, interceptors...)
}

// Create returns a builder for creating a Scope entity.
func (c *ScopeClient) Create() *ScopeCreate {
	mutation := newScopeMutation(c.config, OpCreate)
	return &ScopeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Scope entities.
func (c *ScopeClient) CreateBulk(builders ...*ScopeCreate) *ScopeCreateBulk {
	return &ScopeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScopeClient) MapCreateBulk(slice any, setFunc func(*ScopeCreate, int)) *ScopeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScopeCreateBulk{err: fmt.Errorf("calling to ScopeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScopeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScopeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Scope.
func (c *ScopeClient) Update() *ScopeUpdate {
	mutation := newScopeMutation(c.config, OpUpdate)
	return &ScopeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScopeClient) UpdateOne(_m *Scope) *ScopeUpdateOne {
	mutation := newScopeMutation(c.config, OpUpdateOne, withScope(_m))
	return &ScopeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScopeClient) UpdateOneID(id uint64) *ScopeUpdateOne {
	mutation := newScopeMutation(c.config, OpUpdateOne, withScopeID(id))
	return &ScopeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Scope.
func (c *ScopeClient) Delete() *ScopeDelete {
	mutation := newScopeMutation(c.config, OpDelete)
	return &ScopeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScopeClient) DeleteOne(_m *Scope) *ScopeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScopeClient) DeleteOneID(id uint64) *ScopeDeleteOne {
	builder := c.Delete().Where(scope.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScopeDeleteOne{builder}
}

// Query returns a query builder for Scope.
func (c *ScopeClient) Query() *ScopeQuery {
	return &ScopeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScope},
		inters: c.Interceptors(),
	}
}

// Get returns a Scope entity by its id.
func (c *ScopeClient) Get(ctx context.Context, id uint64) (*Scope, error) {
	return c.Query().Where(scope.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScopeClient) GetX(ctx context.Context, id uint64) *Scope {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParent queries the parent edge of a Scope.
func (c *ScopeClient) QueryParent(_m *Scope) *ScopeQuery {
	query := (&ScopeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scope.Table, scope.FieldID, id),
			sqlgraph.To(scope.Table, scope.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scope.ParentTable, scope.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Scope.
func (c *ScopeClient) QueryChildren(_m *Scope) *ScopeQuery {
	query := (&ScopeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scope.Table, scope.FieldID, id),
			sqlgraph.To(scope.Table, scope.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scope.ChildrenTable, scope.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPermission queries the permission edge of a Scope.
func (c *ScopeClient) QueryPermission(_m *Scope) *PermissionQuery {
	query := (&PermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scope.Table, scope.FieldID, id),
			sqlgraph.To(permission.Table, permission.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, scope.PermissionTable, scope.PermissionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScopeClient) Hooks() []Hook {
	hooks := c.hooks.Scope
	return append(hooks[:len(hooks):len(hooks)], scope.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ScopeClient) Interceptors() []Interceptor {
	inters := c.inters.Scope
	return append(inters[:len(inters):len(inters)], scope.Interceptors[:]...)
}

func (c *ScopeClient) mutate(ctx context.Context, m *ScopeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScopeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScopeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScopeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScopeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Scope mutation op: %q", m.Op())
	}
}

// SystemMonitorClient is a client for the SystemMonitor schema.
type SystemMonitorClient struct {
	config
}

// NewSystemMonitorClient returns a client for the SystemMonitor from the given config.
func NewSystemMonitorClient(c config) *SystemMonitorClient {
	return &SystemMonitorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemmonitor.Hooks(f(g(h())))`.
func (c *SystemMonitorClient) Use(hooks ...Hook) {
	c.hooks.SystemMonitor = append(c.hooks.SystemMonitor, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemmonitor.Intercept(f(g(h())))`.
func (c *SystemMonitorClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemMonitor = append(c.inters.SystemMonitor, interceptors...)
}

// Create returns a builder for creating a SystemMonitor entity.
func (c *SystemMonitorClient) Create() *SystemMonitorCreate {
	mutation := newSystemMonitorMutation(c.config, OpCreate)
	return &SystemMonitorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemMonitor entities.
func (c *SystemMonitorClient) CreateBulk(builders ...*SystemMonitorCreate) *SystemMonitorCreateBulk {
	return &SystemMonitorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemMonitorClient) MapCreateBulk(slice any, setFunc func(*SystemMonitorCreate, int)) *SystemMonitorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemMonitorCreateBulk{err: fmt.Errorf("calling to SystemMonitorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemMonitorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemMonitorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemMonitor.
func (c *SystemMonitorClient) Update() *SystemMonitorUpdate {
	mutation := newSystemMonitorMutation(c.config, OpUpdate)
	return &SystemMonitorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemMonitorClient) UpdateOne(_m *SystemMonitor) *SystemMonitorUpdateOne {
	mutation := newSystemMonitorMutation(c.config, OpUpdateOne, withSystemMonitor(_m))
	return &SystemMonitorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemMonitorClient) UpdateOneID(id uint64) *SystemMonitorUpdateOne {
	mutation := newSystemMonitorMutation(c.config, OpUpdateOne, withSystemMonitorID(id))
	return &SystemMonitorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemMonitor.
func (c *SystemMonitorClient) Delete() *SystemMonitorDelete {
	mutation := newSystemMonitorMutation(c.config, OpDelete)
	return &SystemMonitorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemMonitorClient) DeleteOne(_m *SystemMonitor) *SystemMonitorDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemMonitorClient) DeleteOneID(id uint64) *SystemMonitorDeleteOne {
	builder := c.Delete().Where(systemmonitor.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemMonitorDeleteOne{builder}
}

// Query returns a query builder for SystemMonitor.
func (c *SystemMonitorClient) Query() *SystemMonitorQuery {
	return &SystemMonitorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemMonitor},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemMonitor entity by its id.
func (c *SystemMonitorClient) Get(ctx context.Context, id uint64) (*SystemMonitor, error) {
	return c.Query().Where(systemmonitor.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemMonitorClient) GetX(ctx context.Context, id uint64) *SystemMonitor {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SystemMonitorClient) Hooks() []Hook {
	hooks := c.hooks.SystemMonitor
	return append(hooks[:len(hooks):len(hooks)], systemmonitor.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SystemMonitorClient) Interceptors() []Interceptor {
	return c.inters.SystemMonitor
}

func (c *SystemMonitorClient) mutate(ctx context.Context, m *SystemMonitorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemMonitorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemMonitorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemMonitorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemMonitorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemMonitor mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uint64) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uint64) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uint64) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uint64) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserRoles queries the user_roles edge of a User.
func (c *UserClient) QueryUserRoles(_m *User) *UserRoleQuery {
	query := (&UserRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userrole.Table, userrole.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserRolesTable, user.UserRolesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCredentials queries the credentials edge of a User.
func (c *UserClient) QueryCredentials(_m *User) *CredentialQuery {
	query := (&CredentialClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(credential.Table, credential.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CredentialsTable, user.CredentialsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLoginRecords queries the login_records edge of a User.
func (c *UserClient) QueryLoginRecords(_m *User) *LoginRecordQuery {
	query := (&LoginRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(loginrecord.Table, loginrecord.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LoginRecordsTable, user.LoginRecordsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAvatar queries the avatar edge of a User.
func (c *UserClient) QueryAvatar(_m *User) *AttachmentQuery {
	query := (&AttachmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(attachment.Table, attachment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, user.AvatarTable, user.AvatarColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	hooks := c.hooks.User
	return append(hooks[:len(hooks):len(hooks)], user.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	inters := c.inters.User
	return append(inters[:len(inters):len(inters)], user.Interceptors[:]...)
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserRoleClient is a client for the UserRole schema.
type UserRoleClient struct {
	config
}

// NewUserRoleClient returns a client for the UserRole from the given config.
func NewUserRoleClient(c config) *UserRoleClient {
	return &UserRoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userrole.Hooks(f(g(h())))`.
func (c *UserRoleClient) Use(hooks ...Hook) {
	c.hooks.UserRole = append(c.hooks.UserRole, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userrole.Intercept(f(g(h())))`.
func (c *UserRoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserRole = append(c.inters.UserRole, interceptors...)
}

// Create returns a builder for creating a UserRole entity.
func (c *UserRoleClient) Create() *UserRoleCreate {
	mutation := newUserRoleMutation(c.config, OpCreate)
	return &UserRoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserRole entities.
func (c *UserRoleClient) CreateBulk(builders ...*UserRoleCreate) *UserRoleCreateBulk {
	return &UserRoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserRoleClient) MapCreateBulk(slice any, setFunc func(*UserRoleCreate, int)) *UserRoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserRoleCreateBulk{err: fmt.Errorf("calling to UserRoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserRoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserRoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserRole.
func (c *UserRoleClient) Update() *UserRoleUpdate {
	mutation := newUserRoleMutation(c.config, OpUpdate)
	return &UserRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserRoleClient) UpdateOne(_m *UserRole) *UserRoleUpdateOne {
	mutation := newUserRoleMutation(c.config, OpUpdateOne, withUserRole(_m))
	return &UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserRoleClient) UpdateOneID(id uint64) *UserRoleUpdateOne {
	mutation := newUserRoleMutation(c.config, OpUpdateOne, withUserRoleID(id))
	return &UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserRole.
func (c *UserRoleClient) Delete() *UserRoleDelete {
	mutation := newUserRoleMutation(c.config, OpDelete)
	return &UserRoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserRoleClient) DeleteOne(_m *UserRole) *UserRoleDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserRoleClient) DeleteOneID(id uint64) *UserRoleDeleteOne {
	builder := c.Delete().Where(userrole.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserRoleDeleteOne{builder}
}

// Query returns a query builder for UserRole.
func (c *UserRoleClient) Query() *UserRoleQuery {
	return &UserRoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserRole},
		inters: c.Interceptors(),
	}
}

// Get returns a UserRole entity by its id.
func (c *UserRoleClient) Get(ctx context.Context, id uint64) (*UserRole, error) {
	return c.Query().Where(userrole.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserRoleClient) GetX(ctx context.Context, id uint64) *UserRole {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserRole.
func (c *UserRoleClient) QueryUser(_m *UserRole) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userrole.Table, userrole.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userrole.UserTable, userrole.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRole queries the role edge of a UserRole.
func (c *UserRoleClient) QueryRole(_m *UserRole) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userrole.Table, userrole.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userrole.RoleTable, userrole.RoleColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserRoleClient) Hooks() []Hook {
	hooks := c.hooks.UserRole
	return append(hooks[:len(hooks):len(hooks)], userrole.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserRoleClient) Interceptors() []Interceptor {
	inters := c.inters.UserRole
	return append(inters[:len(inters):len(inters)], userrole.Interceptors[:]...)
}

func (c *UserRoleClient) mutate(ctx context.Context, m *UserRoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserRoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserRoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserRole mutation op: %q", m.Op())
	}
}

// VerifyCodeClient is a client for the VerifyCode schema.
type VerifyCodeClient struct {
	config
}

// NewVerifyCodeClient returns a client for the VerifyCode from the given config.
func NewVerifyCodeClient(c config) *VerifyCodeClient {
	return &VerifyCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `verifycode.Hooks(f(g(h())))`.
func (c *VerifyCodeClient) Use(hooks ...Hook) {
	c.hooks.VerifyCode = append(c.hooks.VerifyCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `verifycode.Intercept(f(g(h())))`.
func (c *VerifyCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.VerifyCode = append(c.inters.VerifyCode, interceptors...)
}

// Create returns a builder for creating a VerifyCode entity.
func (c *VerifyCodeClient) Create() *VerifyCodeCreate {
	mutation := newVerifyCodeMutation(c.config, OpCreate)
	return &VerifyCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VerifyCode entities.
func (c *VerifyCodeClient) CreateBulk(builders ...*VerifyCodeCreate) *VerifyCodeCreateBulk {
	return &VerifyCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VerifyCodeClient) MapCreateBulk(slice any, setFunc func(*VerifyCodeCreate, int)) *VerifyCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VerifyCodeCreateBulk{err: fmt.Errorf("calling to VerifyCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VerifyCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VerifyCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VerifyCode.
func (c *VerifyCodeClient) Update() *VerifyCodeUpdate {
	mutation := newVerifyCodeMutation(c.config, OpUpdate)
	return &VerifyCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VerifyCodeClient) UpdateOne(_m *VerifyCode) *VerifyCodeUpdateOne {
	mutation := newVerifyCodeMutation(c.config, OpUpdateOne, withVerifyCode(_m))
	return &VerifyCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VerifyCodeClient) UpdateOneID(id uint64) *VerifyCodeUpdateOne {
	mutation := newVerifyCodeMutation(c.config, OpUpdateOne, withVerifyCodeID(id))
	return &VerifyCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VerifyCode.
func (c *VerifyCodeClient) Delete() *VerifyCodeDelete {
	mutation := newVerifyCodeMutation(c.config, OpDelete)
	return &VerifyCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VerifyCodeClient) DeleteOne(_m *VerifyCode) *VerifyCodeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VerifyCodeClient) DeleteOneID(id uint64) *VerifyCodeDeleteOne {
	builder := c.Delete().Where(verifycode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VerifyCodeDeleteOne{builder}
}

// Query returns a query builder for VerifyCode.
func (c *VerifyCodeClient) Query() *VerifyCodeQuery {
	return &VerifyCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVerifyCode},
		inters: c.Interceptors(),
	}
}

// Get returns a VerifyCode entity by its id.
func (c *VerifyCodeClient) Get(ctx context.Context, id uint64) (*VerifyCode, error) {
	return c.Query().Where(verifycode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VerifyCodeClient) GetX(ctx context.Context, id uint64) *VerifyCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VerifyCodeClient) Hooks() []Hook {
	hooks := c.hooks.VerifyCode
	return append(hooks[:len(hooks):len(hooks)], verifycode.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *VerifyCodeClient) Interceptors() []Interceptor {
	inters := c.inters.VerifyCode
	return append(inters[:len(inters):len(inters)], verifycode.Interceptors[:]...)
}

func (c *VerifyCodeClient) mutate(ctx context.Context, m *VerifyCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VerifyCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VerifyCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VerifyCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VerifyCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VerifyCode mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		APIAuth, Attachment, ClientDevice, Credential, Logging, LoginRecord,
		OauthApplication, OauthAuthorizationCode, OauthProvider, OauthState,
		OauthToken, OauthUser, OauthUserAuthorization, Permission, Role,
		RolePermission, Scan, Scope, SystemMonitor, User, UserRole,
		VerifyCode []ent.Hook
	}
	inters struct {
		APIAuth, Attachment, ClientDevice, Credential, Logging, LoginRecord,
		OauthApplication, OauthAuthorizationCode, OauthProvider, OauthState,
		OauthToken, OauthUser, OauthUserAuthorization, Permission, Role,
		RolePermission, Scan, Scope, SystemMonitor, User, UserRole,
		VerifyCode []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
