// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"go-backend/database/ent/migrate"

	"go-backend/database/ent/address"
	"go-backend/database/ent/apiauth"
	"go-backend/database/ent/area"
	"go-backend/database/ent/attachment"
	"go-backend/database/ent/clientdevice"
	"go-backend/database/ent/credential"
	"go-backend/database/ent/logging"
	"go-backend/database/ent/loginrecord"
	"go-backend/database/ent/oauthapplication"
	"go-backend/database/ent/oauthauthorizationcode"
	"go-backend/database/ent/oauthprovider"
	"go-backend/database/ent/oauthstate"
	"go-backend/database/ent/oauthtoken"
	"go-backend/database/ent/oauthuser"
	"go-backend/database/ent/oauthuserauthorization"
	"go-backend/database/ent/permission"
	"go-backend/database/ent/role"
	"go-backend/database/ent/rolepermission"
	"go-backend/database/ent/scan"
	"go-backend/database/ent/scope"
	"go-backend/database/ent/station"
	"go-backend/database/ent/subway"
	"go-backend/database/ent/subwaystation"
	"go-backend/database/ent/systemmonitor"
	"go-backend/database/ent/user"
	"go-backend/database/ent/userrole"
	"go-backend/database/ent/verifycode"
	"go-backend/database/ent/workflowapplication"
	"go-backend/database/ent/workflowedge"
	"go-backend/database/ent/workflowexecution"
	"go-backend/database/ent/workflowexecutionlog"
	"go-backend/database/ent/workflownode"
	"go-backend/database/ent/workflownodeexecution"
	"go-backend/database/ent/workflowversion"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// APIAuth is the client for interacting with the APIAuth builders.
	APIAuth *APIAuthClient
	// Address is the client for interacting with the Address builders.
	Address *AddressClient
	// Area is the client for interacting with the Area builders.
	Area *AreaClient
	// Attachment is the client for interacting with the Attachment builders.
	Attachment *AttachmentClient
	// ClientDevice is the client for interacting with the ClientDevice builders.
	ClientDevice *ClientDeviceClient
	// Credential is the client for interacting with the Credential builders.
	Credential *CredentialClient
	// Logging is the client for interacting with the Logging builders.
	Logging *LoggingClient
	// LoginRecord is the client for interacting with the LoginRecord builders.
	LoginRecord *LoginRecordClient
	// OauthApplication is the client for interacting with the OauthApplication builders.
	OauthApplication *OauthApplicationClient
	// OauthAuthorizationCode is the client for interacting with the OauthAuthorizationCode builders.
	OauthAuthorizationCode *OauthAuthorizationCodeClient
	// OauthProvider is the client for interacting with the OauthProvider builders.
	OauthProvider *OauthProviderClient
	// OauthState is the client for interacting with the OauthState builders.
	OauthState *OauthStateClient
	// OauthToken is the client for interacting with the OauthToken builders.
	OauthToken *OauthTokenClient
	// OauthUser is the client for interacting with the OauthUser builders.
	OauthUser *OauthUserClient
	// OauthUserAuthorization is the client for interacting with the OauthUserAuthorization builders.
	OauthUserAuthorization *OauthUserAuthorizationClient
	// Permission is the client for interacting with the Permission builders.
	Permission *PermissionClient
	// Role is the client for interacting with the Role builders.
	Role *RoleClient
	// RolePermission is the client for interacting with the RolePermission builders.
	RolePermission *RolePermissionClient
	// Scan is the client for interacting with the Scan builders.
	Scan *ScanClient
	// Scope is the client for interacting with the Scope builders.
	Scope *ScopeClient
	// Station is the client for interacting with the Station builders.
	Station *StationClient
	// Subway is the client for interacting with the Subway builders.
	Subway *SubwayClient
	// SubwayStation is the client for interacting with the SubwayStation builders.
	SubwayStation *SubwayStationClient
	// SystemMonitor is the client for interacting with the SystemMonitor builders.
	SystemMonitor *SystemMonitorClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserRole is the client for interacting with the UserRole builders.
	UserRole *UserRoleClient
	// VerifyCode is the client for interacting with the VerifyCode builders.
	VerifyCode *VerifyCodeClient
	// WorkflowApplication is the client for interacting with the WorkflowApplication builders.
	WorkflowApplication *WorkflowApplicationClient
	// WorkflowEdge is the client for interacting with the WorkflowEdge builders.
	WorkflowEdge *WorkflowEdgeClient
	// WorkflowExecution is the client for interacting with the WorkflowExecution builders.
	WorkflowExecution *WorkflowExecutionClient
	// WorkflowExecutionLog is the client for interacting with the WorkflowExecutionLog builders.
	WorkflowExecutionLog *WorkflowExecutionLogClient
	// WorkflowNode is the client for interacting with the WorkflowNode builders.
	WorkflowNode *WorkflowNodeClient
	// WorkflowNodeExecution is the client for interacting with the WorkflowNodeExecution builders.
	WorkflowNodeExecution *WorkflowNodeExecutionClient
	// WorkflowVersion is the client for interacting with the WorkflowVersion builders.
	WorkflowVersion *WorkflowVersionClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.APIAuth = NewAPIAuthClient(c.config)
	c.Address = NewAddressClient(c.config)
	c.Area = NewAreaClient(c.config)
	c.Attachment = NewAttachmentClient(c.config)
	c.ClientDevice = NewClientDeviceClient(c.config)
	c.Credential = NewCredentialClient(c.config)
	c.Logging = NewLoggingClient(c.config)
	c.LoginRecord = NewLoginRecordClient(c.config)
	c.OauthApplication = NewOauthApplicationClient(c.config)
	c.OauthAuthorizationCode = NewOauthAuthorizationCodeClient(c.config)
	c.OauthProvider = NewOauthProviderClient(c.config)
	c.OauthState = NewOauthStateClient(c.config)
	c.OauthToken = NewOauthTokenClient(c.config)
	c.OauthUser = NewOauthUserClient(c.config)
	c.OauthUserAuthorization = NewOauthUserAuthorizationClient(c.config)
	c.Permission = NewPermissionClient(c.config)
	c.Role = NewRoleClient(c.config)
	c.RolePermission = NewRolePermissionClient(c.config)
	c.Scan = NewScanClient(c.config)
	c.Scope = NewScopeClient(c.config)
	c.Station = NewStationClient(c.config)
	c.Subway = NewSubwayClient(c.config)
	c.SubwayStation = NewSubwayStationClient(c.config)
	c.SystemMonitor = NewSystemMonitorClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserRole = NewUserRoleClient(c.config)
	c.VerifyCode = NewVerifyCodeClient(c.config)
	c.WorkflowApplication = NewWorkflowApplicationClient(c.config)
	c.WorkflowEdge = NewWorkflowEdgeClient(c.config)
	c.WorkflowExecution = NewWorkflowExecutionClient(c.config)
	c.WorkflowExecutionLog = NewWorkflowExecutionLogClient(c.config)
	c.WorkflowNode = NewWorkflowNodeClient(c.config)
	c.WorkflowNodeExecution = NewWorkflowNodeExecutionClient(c.config)
	c.WorkflowVersion = NewWorkflowVersionClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		APIAuth:                NewAPIAuthClient(cfg),
		Address:                NewAddressClient(cfg),
		Area:                   NewAreaClient(cfg),
		Attachment:             NewAttachmentClient(cfg),
		ClientDevice:           NewClientDeviceClient(cfg),
		Credential:             NewCredentialClient(cfg),
		Logging:                NewLoggingClient(cfg),
		LoginRecord:            NewLoginRecordClient(cfg),
		OauthApplication:       NewOauthApplicationClient(cfg),
		OauthAuthorizationCode: NewOauthAuthorizationCodeClient(cfg),
		OauthProvider:          NewOauthProviderClient(cfg),
		OauthState:             NewOauthStateClient(cfg),
		OauthToken:             NewOauthTokenClient(cfg),
		OauthUser:              NewOauthUserClient(cfg),
		OauthUserAuthorization: NewOauthUserAuthorizationClient(cfg),
		Permission:             NewPermissionClient(cfg),
		Role:                   NewRoleClient(cfg),
		RolePermission:         NewRolePermissionClient(cfg),
		Scan:                   NewScanClient(cfg),
		Scope:                  NewScopeClient(cfg),
		Station:                NewStationClient(cfg),
		Subway:                 NewSubwayClient(cfg),
		SubwayStation:          NewSubwayStationClient(cfg),
		SystemMonitor:          NewSystemMonitorClient(cfg),
		User:                   NewUserClient(cfg),
		UserRole:               NewUserRoleClient(cfg),
		VerifyCode:             NewVerifyCodeClient(cfg),
		WorkflowApplication:    NewWorkflowApplicationClient(cfg),
		WorkflowEdge:           NewWorkflowEdgeClient(cfg),
		WorkflowExecution:      NewWorkflowExecutionClient(cfg),
		WorkflowExecutionLog:   NewWorkflowExecutionLogClient(cfg),
		WorkflowNode:           NewWorkflowNodeClient(cfg),
		WorkflowNodeExecution:  NewWorkflowNodeExecutionClient(cfg),
		WorkflowVersion:        NewWorkflowVersionClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		APIAuth:                NewAPIAuthClient(cfg),
		Address:                NewAddressClient(cfg),
		Area:                   NewAreaClient(cfg),
		Attachment:             NewAttachmentClient(cfg),
		ClientDevice:           NewClientDeviceClient(cfg),
		Credential:             NewCredentialClient(cfg),
		Logging:                NewLoggingClient(cfg),
		LoginRecord:            NewLoginRecordClient(cfg),
		OauthApplication:       NewOauthApplicationClient(cfg),
		OauthAuthorizationCode: NewOauthAuthorizationCodeClient(cfg),
		OauthProvider:          NewOauthProviderClient(cfg),
		OauthState:             NewOauthStateClient(cfg),
		OauthToken:             NewOauthTokenClient(cfg),
		OauthUser:              NewOauthUserClient(cfg),
		OauthUserAuthorization: NewOauthUserAuthorizationClient(cfg),
		Permission:             NewPermissionClient(cfg),
		Role:                   NewRoleClient(cfg),
		RolePermission:         NewRolePermissionClient(cfg),
		Scan:                   NewScanClient(cfg),
		Scope:                  NewScopeClient(cfg),
		Station:                NewStationClient(cfg),
		Subway:                 NewSubwayClient(cfg),
		SubwayStation:          NewSubwayStationClient(cfg),
		SystemMonitor:          NewSystemMonitorClient(cfg),
		User:                   NewUserClient(cfg),
		UserRole:               NewUserRoleClient(cfg),
		VerifyCode:             NewVerifyCodeClient(cfg),
		WorkflowApplication:    NewWorkflowApplicationClient(cfg),
		WorkflowEdge:           NewWorkflowEdgeClient(cfg),
		WorkflowExecution:      NewWorkflowExecutionClient(cfg),
		WorkflowExecutionLog:   NewWorkflowExecutionLogClient(cfg),
		WorkflowNode:           NewWorkflowNodeClient(cfg),
		WorkflowNodeExecution:  NewWorkflowNodeExecutionClient(cfg),
		WorkflowVersion:        NewWorkflowVersionClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		APIAuth.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.APIAuth, c.Address, c.Area, c.Attachment, c.ClientDevice, c.Credential,
		c.Logging, c.LoginRecord, c.OauthApplication, c.OauthAuthorizationCode,
		c.OauthProvider, c.OauthState, c.OauthToken, c.OauthUser,
		c.OauthUserAuthorization, c.Permission, c.Role, c.RolePermission, c.Scan,
		c.Scope, c.Station, c.Subway, c.SubwayStation, c.SystemMonitor, c.User,
		c.UserRole, c.VerifyCode, c.WorkflowApplication, c.WorkflowEdge,
		c.WorkflowExecution, c.WorkflowExecutionLog, c.WorkflowNode,
		c.WorkflowNodeExecution, c.WorkflowVersion,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.APIAuth, c.Address, c.Area, c.Attachment, c.ClientDevice, c.Credential,
		c.Logging, c.LoginRecord, c.OauthApplication, c.OauthAuthorizationCode,
		c.OauthProvider, c.OauthState, c.OauthToken, c.OauthUser,
		c.OauthUserAuthorization, c.Permission, c.Role, c.RolePermission, c.Scan,
		c.Scope, c.Station, c.Subway, c.SubwayStation, c.SystemMonitor, c.User,
		c.UserRole, c.VerifyCode, c.WorkflowApplication, c.WorkflowEdge,
		c.WorkflowExecution, c.WorkflowExecutionLog, c.WorkflowNode,
		c.WorkflowNodeExecution, c.WorkflowVersion,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *APIAuthMutation:
		return c.APIAuth.mutate(ctx, m)
	case *AddressMutation:
		return c.Address.mutate(ctx, m)
	case *AreaMutation:
		return c.Area.mutate(ctx, m)
	case *AttachmentMutation:
		return c.Attachment.mutate(ctx, m)
	case *ClientDeviceMutation:
		return c.ClientDevice.mutate(ctx, m)
	case *CredentialMutation:
		return c.Credential.mutate(ctx, m)
	case *LoggingMutation:
		return c.Logging.mutate(ctx, m)
	case *LoginRecordMutation:
		return c.LoginRecord.mutate(ctx, m)
	case *OauthApplicationMutation:
		return c.OauthApplication.mutate(ctx, m)
	case *OauthAuthorizationCodeMutation:
		return c.OauthAuthorizationCode.mutate(ctx, m)
	case *OauthProviderMutation:
		return c.OauthProvider.mutate(ctx, m)
	case *OauthStateMutation:
		return c.OauthState.mutate(ctx, m)
	case *OauthTokenMutation:
		return c.OauthToken.mutate(ctx, m)
	case *OauthUserMutation:
		return c.OauthUser.mutate(ctx, m)
	case *OauthUserAuthorizationMutation:
		return c.OauthUserAuthorization.mutate(ctx, m)
	case *PermissionMutation:
		return c.Permission.mutate(ctx, m)
	case *RoleMutation:
		return c.Role.mutate(ctx, m)
	case *RolePermissionMutation:
		return c.RolePermission.mutate(ctx, m)
	case *ScanMutation:
		return c.Scan.mutate(ctx, m)
	case *ScopeMutation:
		return c.Scope.mutate(ctx, m)
	case *StationMutation:
		return c.Station.mutate(ctx, m)
	case *SubwayMutation:
		return c.Subway.mutate(ctx, m)
	case *SubwayStationMutation:
		return c.SubwayStation.mutate(ctx, m)
	case *SystemMonitorMutation:
		return c.SystemMonitor.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserRoleMutation:
		return c.UserRole.mutate(ctx, m)
	case *VerifyCodeMutation:
		return c.VerifyCode.mutate(ctx, m)
	case *WorkflowApplicationMutation:
		return c.WorkflowApplication.mutate(ctx, m)
	case *WorkflowEdgeMutation:
		return c.WorkflowEdge.mutate(ctx, m)
	case *WorkflowExecutionMutation:
		return c.WorkflowExecution.mutate(ctx, m)
	case *WorkflowExecutionLogMutation:
		return c.WorkflowExecutionLog.mutate(ctx, m)
	case *WorkflowNodeMutation:
		return c.WorkflowNode.mutate(ctx, m)
	case *WorkflowNodeExecutionMutation:
		return c.WorkflowNodeExecution.mutate(ctx, m)
	case *WorkflowVersionMutation:
		return c.WorkflowVersion.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// APIAuthClient is a client for the APIAuth schema.
type APIAuthClient struct {
	config
}

// NewAPIAuthClient returns a client for the APIAuth from the given config.
func NewAPIAuthClient(c config) *APIAuthClient {
	return &APIAuthClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `apiauth.Hooks(f(g(h())))`.
func (c *APIAuthClient) Use(hooks ...Hook) {
	c.hooks.APIAuth = append(c.hooks.APIAuth, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `apiauth.Intercept(f(g(h())))`.
func (c *APIAuthClient) Intercept(interceptors ...Interceptor) {
	c.inters.APIAuth = append(c.inters.APIAuth, interceptors...)
}

// Create returns a builder for creating a APIAuth entity.
func (c *APIAuthClient) Create() *APIAuthCreate {
	mutation := newAPIAuthMutation(c.config, OpCreate)
	return &APIAuthCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of APIAuth entities.
func (c *APIAuthClient) CreateBulk(builders ...*APIAuthCreate) *APIAuthCreateBulk {
	return &APIAuthCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *APIAuthClient) MapCreateBulk(slice any, setFunc func(*APIAuthCreate, int)) *APIAuthCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &APIAuthCreateBulk{err: fmt.Errorf("calling to APIAuthClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*APIAuthCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &APIAuthCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for APIAuth.
func (c *APIAuthClient) Update() *APIAuthUpdate {
	mutation := newAPIAuthMutation(c.config, OpUpdate)
	return &APIAuthUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *APIAuthClient) UpdateOne(_m *APIAuth) *APIAuthUpdateOne {
	mutation := newAPIAuthMutation(c.config, OpUpdateOne, withAPIAuth(_m))
	return &APIAuthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *APIAuthClient) UpdateOneID(id uint64) *APIAuthUpdateOne {
	mutation := newAPIAuthMutation(c.config, OpUpdateOne, withAPIAuthID(id))
	return &APIAuthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for APIAuth.
func (c *APIAuthClient) Delete() *APIAuthDelete {
	mutation := newAPIAuthMutation(c.config, OpDelete)
	return &APIAuthDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *APIAuthClient) DeleteOne(_m *APIAuth) *APIAuthDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *APIAuthClient) DeleteOneID(id uint64) *APIAuthDeleteOne {
	builder := c.Delete().Where(apiauth.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &APIAuthDeleteOne{builder}
}

// Query returns a query builder for APIAuth.
func (c *APIAuthClient) Query() *APIAuthQuery {
	return &APIAuthQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAPIAuth},
		inters: c.Interceptors(),
	}
}

// Get returns a APIAuth entity by its id.
func (c *APIAuthClient) Get(ctx context.Context, id uint64) (*APIAuth, error) {
	return c.Query().Where(apiauth.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *APIAuthClient) GetX(ctx context.Context, id uint64) *APIAuth {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPermissions queries the permissions edge of a APIAuth.
func (c *APIAuthClient) QueryPermissions(_m *APIAuth) *PermissionQuery {
	query := (&PermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(apiauth.Table, apiauth.FieldID, id),
			sqlgraph.To(permission.Table, permission.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, apiauth.PermissionsTable, apiauth.PermissionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *APIAuthClient) Hooks() []Hook {
	hooks := c.hooks.APIAuth
	return append(hooks[:len(hooks):len(hooks)], apiauth.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *APIAuthClient) Interceptors() []Interceptor {
	inters := c.inters.APIAuth
	return append(inters[:len(inters):len(inters)], apiauth.Interceptors[:]...)
}

func (c *APIAuthClient) mutate(ctx context.Context, m *APIAuthMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&APIAuthCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&APIAuthUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&APIAuthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&APIAuthDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown APIAuth mutation op: %q", m.Op())
	}
}

// AddressClient is a client for the Address schema.
type AddressClient struct {
	config
}

// NewAddressClient returns a client for the Address from the given config.
func NewAddressClient(c config) *AddressClient {
	return &AddressClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `address.Hooks(f(g(h())))`.
func (c *AddressClient) Use(hooks ...Hook) {
	c.hooks.Address = append(c.hooks.Address, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `address.Intercept(f(g(h())))`.
func (c *AddressClient) Intercept(interceptors ...Interceptor) {
	c.inters.Address = append(c.inters.Address, interceptors...)
}

// Create returns a builder for creating a Address entity.
func (c *AddressClient) Create() *AddressCreate {
	mutation := newAddressMutation(c.config, OpCreate)
	return &AddressCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Address entities.
func (c *AddressClient) CreateBulk(builders ...*AddressCreate) *AddressCreateBulk {
	return &AddressCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AddressClient) MapCreateBulk(slice any, setFunc func(*AddressCreate, int)) *AddressCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AddressCreateBulk{err: fmt.Errorf("calling to AddressClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AddressCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AddressCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Address.
func (c *AddressClient) Update() *AddressUpdate {
	mutation := newAddressMutation(c.config, OpUpdate)
	return &AddressUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AddressClient) UpdateOne(_m *Address) *AddressUpdateOne {
	mutation := newAddressMutation(c.config, OpUpdateOne, withAddress(_m))
	return &AddressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AddressClient) UpdateOneID(id uint64) *AddressUpdateOne {
	mutation := newAddressMutation(c.config, OpUpdateOne, withAddressID(id))
	return &AddressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Address.
func (c *AddressClient) Delete() *AddressDelete {
	mutation := newAddressMutation(c.config, OpDelete)
	return &AddressDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AddressClient) DeleteOne(_m *Address) *AddressDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AddressClient) DeleteOneID(id uint64) *AddressDeleteOne {
	builder := c.Delete().Where(address.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AddressDeleteOne{builder}
}

// Query returns a query builder for Address.
func (c *AddressClient) Query() *AddressQuery {
	return &AddressQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAddress},
		inters: c.Interceptors(),
	}
}

// Get returns a Address entity by its id.
func (c *AddressClient) Get(ctx context.Context, id uint64) (*Address, error) {
	return c.Query().Where(address.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AddressClient) GetX(ctx context.Context, id uint64) *Address {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArea queries the area edge of a Address.
func (c *AddressClient) QueryArea(_m *Address) *AreaQuery {
	query := (&AreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(address.Table, address.FieldID, id),
			sqlgraph.To(area.Table, area.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, address.AreaTable, address.AreaColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AddressClient) Hooks() []Hook {
	hooks := c.hooks.Address
	return append(hooks[:len(hooks):len(hooks)], address.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AddressClient) Interceptors() []Interceptor {
	inters := c.inters.Address
	return append(inters[:len(inters):len(inters)], address.Interceptors[:]...)
}

func (c *AddressClient) mutate(ctx context.Context, m *AddressMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AddressCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AddressUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AddressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AddressDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Address mutation op: %q", m.Op())
	}
}

// AreaClient is a client for the Area schema.
type AreaClient struct {
	config
}

// NewAreaClient returns a client for the Area from the given config.
func NewAreaClient(c config) *AreaClient {
	return &AreaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `area.Hooks(f(g(h())))`.
func (c *AreaClient) Use(hooks ...Hook) {
	c.hooks.Area = append(c.hooks.Area, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `area.Intercept(f(g(h())))`.
func (c *AreaClient) Intercept(interceptors ...Interceptor) {
	c.inters.Area = append(c.inters.Area, interceptors...)
}

// Create returns a builder for creating a Area entity.
func (c *AreaClient) Create() *AreaCreate {
	mutation := newAreaMutation(c.config, OpCreate)
	return &AreaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Area entities.
func (c *AreaClient) CreateBulk(builders ...*AreaCreate) *AreaCreateBulk {
	return &AreaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AreaClient) MapCreateBulk(slice any, setFunc func(*AreaCreate, int)) *AreaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AreaCreateBulk{err: fmt.Errorf("calling to AreaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AreaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AreaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Area.
func (c *AreaClient) Update() *AreaUpdate {
	mutation := newAreaMutation(c.config, OpUpdate)
	return &AreaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AreaClient) UpdateOne(_m *Area) *AreaUpdateOne {
	mutation := newAreaMutation(c.config, OpUpdateOne, withArea(_m))
	return &AreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AreaClient) UpdateOneID(id uint64) *AreaUpdateOne {
	mutation := newAreaMutation(c.config, OpUpdateOne, withAreaID(id))
	return &AreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Area.
func (c *AreaClient) Delete() *AreaDelete {
	mutation := newAreaMutation(c.config, OpDelete)
	return &AreaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AreaClient) DeleteOne(_m *Area) *AreaDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AreaClient) DeleteOneID(id uint64) *AreaDeleteOne {
	builder := c.Delete().Where(area.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AreaDeleteOne{builder}
}

// Query returns a query builder for Area.
func (c *AreaClient) Query() *AreaQuery {
	return &AreaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeArea},
		inters: c.Interceptors(),
	}
}

// Get returns a Area entity by its id.
func (c *AreaClient) Get(ctx context.Context, id uint64) (*Area, error) {
	return c.Query().Where(area.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AreaClient) GetX(ctx context.Context, id uint64) *Area {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryChildren queries the children edge of a Area.
func (c *AreaClient) QueryChildren(_m *Area) *AreaQuery {
	query := (&AreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(area.Table, area.FieldID, id),
			sqlgraph.To(area.Table, area.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, area.ChildrenTable, area.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Area.
func (c *AreaClient) QueryParent(_m *Area) *AreaQuery {
	query := (&AreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(area.Table, area.FieldID, id),
			sqlgraph.To(area.Table, area.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, area.ParentTable, area.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAddresses queries the addresses edge of a Area.
func (c *AreaClient) QueryAddresses(_m *Area) *AddressQuery {
	query := (&AddressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(area.Table, area.FieldID, id),
			sqlgraph.To(address.Table, address.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, area.AddressesTable, area.AddressesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStations queries the stations edge of a Area.
func (c *AreaClient) QueryStations(_m *Area) *StationQuery {
	query := (&StationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(area.Table, area.FieldID, id),
			sqlgraph.To(station.Table, station.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, area.StationsTable, area.StationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubways queries the subways edge of a Area.
func (c *AreaClient) QuerySubways(_m *Area) *SubwayQuery {
	query := (&SubwayClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(area.Table, area.FieldID, id),
			sqlgraph.To(subway.Table, subway.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, area.SubwaysTable, area.SubwaysColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AreaClient) Hooks() []Hook {
	hooks := c.hooks.Area
	return append(hooks[:len(hooks):len(hooks)], area.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AreaClient) Interceptors() []Interceptor {
	inters := c.inters.Area
	return append(inters[:len(inters):len(inters)], area.Interceptors[:]...)
}

func (c *AreaClient) mutate(ctx context.Context, m *AreaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AreaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AreaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AreaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Area mutation op: %q", m.Op())
	}
}

// AttachmentClient is a client for the Attachment schema.
type AttachmentClient struct {
	config
}

// NewAttachmentClient returns a client for the Attachment from the given config.
func NewAttachmentClient(c config) *AttachmentClient {
	return &AttachmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `attachment.Hooks(f(g(h())))`.
func (c *AttachmentClient) Use(hooks ...Hook) {
	c.hooks.Attachment = append(c.hooks.Attachment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `attachment.Intercept(f(g(h())))`.
func (c *AttachmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Attachment = append(c.inters.Attachment, interceptors...)
}

// Create returns a builder for creating a Attachment entity.
func (c *AttachmentClient) Create() *AttachmentCreate {
	mutation := newAttachmentMutation(c.config, OpCreate)
	return &AttachmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Attachment entities.
func (c *AttachmentClient) CreateBulk(builders ...*AttachmentCreate) *AttachmentCreateBulk {
	return &AttachmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AttachmentClient) MapCreateBulk(slice any, setFunc func(*AttachmentCreate, int)) *AttachmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AttachmentCreateBulk{err: fmt.Errorf("calling to AttachmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AttachmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AttachmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Attachment.
func (c *AttachmentClient) Update() *AttachmentUpdate {
	mutation := newAttachmentMutation(c.config, OpUpdate)
	return &AttachmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AttachmentClient) UpdateOne(_m *Attachment) *AttachmentUpdateOne {
	mutation := newAttachmentMutation(c.config, OpUpdateOne, withAttachment(_m))
	return &AttachmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AttachmentClient) UpdateOneID(id uint64) *AttachmentUpdateOne {
	mutation := newAttachmentMutation(c.config, OpUpdateOne, withAttachmentID(id))
	return &AttachmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Attachment.
func (c *AttachmentClient) Delete() *AttachmentDelete {
	mutation := newAttachmentMutation(c.config, OpDelete)
	return &AttachmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AttachmentClient) DeleteOne(_m *Attachment) *AttachmentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AttachmentClient) DeleteOneID(id uint64) *AttachmentDeleteOne {
	builder := c.Delete().Where(attachment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AttachmentDeleteOne{builder}
}

// Query returns a query builder for Attachment.
func (c *AttachmentClient) Query() *AttachmentQuery {
	return &AttachmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAttachment},
		inters: c.Interceptors(),
	}
}

// Get returns a Attachment entity by its id.
func (c *AttachmentClient) Get(ctx context.Context, id uint64) (*Attachment, error) {
	return c.Query().Where(attachment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AttachmentClient) GetX(ctx context.Context, id uint64) *Attachment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AttachmentClient) Hooks() []Hook {
	hooks := c.hooks.Attachment
	return append(hooks[:len(hooks):len(hooks)], attachment.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AttachmentClient) Interceptors() []Interceptor {
	inters := c.inters.Attachment
	return append(inters[:len(inters):len(inters)], attachment.Interceptors[:]...)
}

func (c *AttachmentClient) mutate(ctx context.Context, m *AttachmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AttachmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AttachmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AttachmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AttachmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Attachment mutation op: %q", m.Op())
	}
}

// ClientDeviceClient is a client for the ClientDevice schema.
type ClientDeviceClient struct {
	config
}

// NewClientDeviceClient returns a client for the ClientDevice from the given config.
func NewClientDeviceClient(c config) *ClientDeviceClient {
	return &ClientDeviceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `clientdevice.Hooks(f(g(h())))`.
func (c *ClientDeviceClient) Use(hooks ...Hook) {
	c.hooks.ClientDevice = append(c.hooks.ClientDevice, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `clientdevice.Intercept(f(g(h())))`.
func (c *ClientDeviceClient) Intercept(interceptors ...Interceptor) {
	c.inters.ClientDevice = append(c.inters.ClientDevice, interceptors...)
}

// Create returns a builder for creating a ClientDevice entity.
func (c *ClientDeviceClient) Create() *ClientDeviceCreate {
	mutation := newClientDeviceMutation(c.config, OpCreate)
	return &ClientDeviceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ClientDevice entities.
func (c *ClientDeviceClient) CreateBulk(builders ...*ClientDeviceCreate) *ClientDeviceCreateBulk {
	return &ClientDeviceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ClientDeviceClient) MapCreateBulk(slice any, setFunc func(*ClientDeviceCreate, int)) *ClientDeviceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ClientDeviceCreateBulk{err: fmt.Errorf("calling to ClientDeviceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ClientDeviceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ClientDeviceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ClientDevice.
func (c *ClientDeviceClient) Update() *ClientDeviceUpdate {
	mutation := newClientDeviceMutation(c.config, OpUpdate)
	return &ClientDeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClientDeviceClient) UpdateOne(_m *ClientDevice) *ClientDeviceUpdateOne {
	mutation := newClientDeviceMutation(c.config, OpUpdateOne, withClientDevice(_m))
	return &ClientDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClientDeviceClient) UpdateOneID(id uint64) *ClientDeviceUpdateOne {
	mutation := newClientDeviceMutation(c.config, OpUpdateOne, withClientDeviceID(id))
	return &ClientDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ClientDevice.
func (c *ClientDeviceClient) Delete() *ClientDeviceDelete {
	mutation := newClientDeviceMutation(c.config, OpDelete)
	return &ClientDeviceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ClientDeviceClient) DeleteOne(_m *ClientDevice) *ClientDeviceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ClientDeviceClient) DeleteOneID(id uint64) *ClientDeviceDeleteOne {
	builder := c.Delete().Where(clientdevice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClientDeviceDeleteOne{builder}
}

// Query returns a query builder for ClientDevice.
func (c *ClientDeviceClient) Query() *ClientDeviceQuery {
	return &ClientDeviceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeClientDevice},
		inters: c.Interceptors(),
	}
}

// Get returns a ClientDevice entity by its id.
func (c *ClientDeviceClient) Get(ctx context.Context, id uint64) (*ClientDevice, error) {
	return c.Query().Where(clientdevice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClientDeviceClient) GetX(ctx context.Context, id uint64) *ClientDevice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoles queries the roles edge of a ClientDevice.
func (c *ClientDeviceClient) QueryRoles(_m *ClientDevice) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(clientdevice.Table, clientdevice.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, clientdevice.RolesTable, clientdevice.RolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ClientDeviceClient) Hooks() []Hook {
	hooks := c.hooks.ClientDevice
	return append(hooks[:len(hooks):len(hooks)], clientdevice.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ClientDeviceClient) Interceptors() []Interceptor {
	inters := c.inters.ClientDevice
	return append(inters[:len(inters):len(inters)], clientdevice.Interceptors[:]...)
}

func (c *ClientDeviceClient) mutate(ctx context.Context, m *ClientDeviceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ClientDeviceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ClientDeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ClientDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ClientDeviceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ClientDevice mutation op: %q", m.Op())
	}
}

// CredentialClient is a client for the Credential schema.
type CredentialClient struct {
	config
}

// NewCredentialClient returns a client for the Credential from the given config.
func NewCredentialClient(c config) *CredentialClient {
	return &CredentialClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `credential.Hooks(f(g(h())))`.
func (c *CredentialClient) Use(hooks ...Hook) {
	c.hooks.Credential = append(c.hooks.Credential, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `credential.Intercept(f(g(h())))`.
func (c *CredentialClient) Intercept(interceptors ...Interceptor) {
	c.inters.Credential = append(c.inters.Credential, interceptors...)
}

// Create returns a builder for creating a Credential entity.
func (c *CredentialClient) Create() *CredentialCreate {
	mutation := newCredentialMutation(c.config, OpCreate)
	return &CredentialCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Credential entities.
func (c *CredentialClient) CreateBulk(builders ...*CredentialCreate) *CredentialCreateBulk {
	return &CredentialCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CredentialClient) MapCreateBulk(slice any, setFunc func(*CredentialCreate, int)) *CredentialCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CredentialCreateBulk{err: fmt.Errorf("calling to CredentialClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CredentialCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CredentialCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Credential.
func (c *CredentialClient) Update() *CredentialUpdate {
	mutation := newCredentialMutation(c.config, OpUpdate)
	return &CredentialUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CredentialClient) UpdateOne(_m *Credential) *CredentialUpdateOne {
	mutation := newCredentialMutation(c.config, OpUpdateOne, withCredential(_m))
	return &CredentialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CredentialClient) UpdateOneID(id uint64) *CredentialUpdateOne {
	mutation := newCredentialMutation(c.config, OpUpdateOne, withCredentialID(id))
	return &CredentialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Credential.
func (c *CredentialClient) Delete() *CredentialDelete {
	mutation := newCredentialMutation(c.config, OpDelete)
	return &CredentialDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CredentialClient) DeleteOne(_m *Credential) *CredentialDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CredentialClient) DeleteOneID(id uint64) *CredentialDeleteOne {
	builder := c.Delete().Where(credential.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CredentialDeleteOne{builder}
}

// Query returns a query builder for Credential.
func (c *CredentialClient) Query() *CredentialQuery {
	return &CredentialQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCredential},
		inters: c.Interceptors(),
	}
}

// Get returns a Credential entity by its id.
func (c *CredentialClient) Get(ctx context.Context, id uint64) (*Credential, error) {
	return c.Query().Where(credential.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CredentialClient) GetX(ctx context.Context, id uint64) *Credential {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Credential.
func (c *CredentialClient) QueryUser(_m *Credential) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(credential.Table, credential.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, credential.UserTable, credential.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CredentialClient) Hooks() []Hook {
	hooks := c.hooks.Credential
	return append(hooks[:len(hooks):len(hooks)], credential.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CredentialClient) Interceptors() []Interceptor {
	inters := c.inters.Credential
	return append(inters[:len(inters):len(inters)], credential.Interceptors[:]...)
}

func (c *CredentialClient) mutate(ctx context.Context, m *CredentialMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CredentialCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CredentialUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CredentialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CredentialDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Credential mutation op: %q", m.Op())
	}
}

// LoggingClient is a client for the Logging schema.
type LoggingClient struct {
	config
}

// NewLoggingClient returns a client for the Logging from the given config.
func NewLoggingClient(c config) *LoggingClient {
	return &LoggingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `logging.Hooks(f(g(h())))`.
func (c *LoggingClient) Use(hooks ...Hook) {
	c.hooks.Logging = append(c.hooks.Logging, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `logging.Intercept(f(g(h())))`.
func (c *LoggingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Logging = append(c.inters.Logging, interceptors...)
}

// Create returns a builder for creating a Logging entity.
func (c *LoggingClient) Create() *LoggingCreate {
	mutation := newLoggingMutation(c.config, OpCreate)
	return &LoggingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Logging entities.
func (c *LoggingClient) CreateBulk(builders ...*LoggingCreate) *LoggingCreateBulk {
	return &LoggingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LoggingClient) MapCreateBulk(slice any, setFunc func(*LoggingCreate, int)) *LoggingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LoggingCreateBulk{err: fmt.Errorf("calling to LoggingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LoggingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LoggingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Logging.
func (c *LoggingClient) Update() *LoggingUpdate {
	mutation := newLoggingMutation(c.config, OpUpdate)
	return &LoggingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LoggingClient) UpdateOne(_m *Logging) *LoggingUpdateOne {
	mutation := newLoggingMutation(c.config, OpUpdateOne, withLogging(_m))
	return &LoggingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LoggingClient) UpdateOneID(id uint64) *LoggingUpdateOne {
	mutation := newLoggingMutation(c.config, OpUpdateOne, withLoggingID(id))
	return &LoggingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Logging.
func (c *LoggingClient) Delete() *LoggingDelete {
	mutation := newLoggingMutation(c.config, OpDelete)
	return &LoggingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LoggingClient) DeleteOne(_m *Logging) *LoggingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LoggingClient) DeleteOneID(id uint64) *LoggingDeleteOne {
	builder := c.Delete().Where(logging.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LoggingDeleteOne{builder}
}

// Query returns a query builder for Logging.
func (c *LoggingClient) Query() *LoggingQuery {
	return &LoggingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLogging},
		inters: c.Interceptors(),
	}
}

// Get returns a Logging entity by its id.
func (c *LoggingClient) Get(ctx context.Context, id uint64) (*Logging, error) {
	return c.Query().Where(logging.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LoggingClient) GetX(ctx context.Context, id uint64) *Logging {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *LoggingClient) Hooks() []Hook {
	hooks := c.hooks.Logging
	return append(hooks[:len(hooks):len(hooks)], logging.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *LoggingClient) Interceptors() []Interceptor {
	inters := c.inters.Logging
	return append(inters[:len(inters):len(inters)], logging.Interceptors[:]...)
}

func (c *LoggingClient) mutate(ctx context.Context, m *LoggingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LoggingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LoggingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LoggingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LoggingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Logging mutation op: %q", m.Op())
	}
}

// LoginRecordClient is a client for the LoginRecord schema.
type LoginRecordClient struct {
	config
}

// NewLoginRecordClient returns a client for the LoginRecord from the given config.
func NewLoginRecordClient(c config) *LoginRecordClient {
	return &LoginRecordClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `loginrecord.Hooks(f(g(h())))`.
func (c *LoginRecordClient) Use(hooks ...Hook) {
	c.hooks.LoginRecord = append(c.hooks.LoginRecord, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `loginrecord.Intercept(f(g(h())))`.
func (c *LoginRecordClient) Intercept(interceptors ...Interceptor) {
	c.inters.LoginRecord = append(c.inters.LoginRecord, interceptors...)
}

// Create returns a builder for creating a LoginRecord entity.
func (c *LoginRecordClient) Create() *LoginRecordCreate {
	mutation := newLoginRecordMutation(c.config, OpCreate)
	return &LoginRecordCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LoginRecord entities.
func (c *LoginRecordClient) CreateBulk(builders ...*LoginRecordCreate) *LoginRecordCreateBulk {
	return &LoginRecordCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LoginRecordClient) MapCreateBulk(slice any, setFunc func(*LoginRecordCreate, int)) *LoginRecordCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LoginRecordCreateBulk{err: fmt.Errorf("calling to LoginRecordClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LoginRecordCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LoginRecordCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LoginRecord.
func (c *LoginRecordClient) Update() *LoginRecordUpdate {
	mutation := newLoginRecordMutation(c.config, OpUpdate)
	return &LoginRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LoginRecordClient) UpdateOne(_m *LoginRecord) *LoginRecordUpdateOne {
	mutation := newLoginRecordMutation(c.config, OpUpdateOne, withLoginRecord(_m))
	return &LoginRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LoginRecordClient) UpdateOneID(id uint64) *LoginRecordUpdateOne {
	mutation := newLoginRecordMutation(c.config, OpUpdateOne, withLoginRecordID(id))
	return &LoginRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LoginRecord.
func (c *LoginRecordClient) Delete() *LoginRecordDelete {
	mutation := newLoginRecordMutation(c.config, OpDelete)
	return &LoginRecordDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LoginRecordClient) DeleteOne(_m *LoginRecord) *LoginRecordDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LoginRecordClient) DeleteOneID(id uint64) *LoginRecordDeleteOne {
	builder := c.Delete().Where(loginrecord.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LoginRecordDeleteOne{builder}
}

// Query returns a query builder for LoginRecord.
func (c *LoginRecordClient) Query() *LoginRecordQuery {
	return &LoginRecordQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLoginRecord},
		inters: c.Interceptors(),
	}
}

// Get returns a LoginRecord entity by its id.
func (c *LoginRecordClient) Get(ctx context.Context, id uint64) (*LoginRecord, error) {
	return c.Query().Where(loginrecord.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LoginRecordClient) GetX(ctx context.Context, id uint64) *LoginRecord {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a LoginRecord.
func (c *LoginRecordClient) QueryUser(_m *LoginRecord) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(loginrecord.Table, loginrecord.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, loginrecord.UserTable, loginrecord.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LoginRecordClient) Hooks() []Hook {
	hooks := c.hooks.LoginRecord
	return append(hooks[:len(hooks):len(hooks)], loginrecord.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *LoginRecordClient) Interceptors() []Interceptor {
	return c.inters.LoginRecord
}

func (c *LoginRecordClient) mutate(ctx context.Context, m *LoginRecordMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LoginRecordCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LoginRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LoginRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LoginRecordDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LoginRecord mutation op: %q", m.Op())
	}
}

// OauthApplicationClient is a client for the OauthApplication schema.
type OauthApplicationClient struct {
	config
}

// NewOauthApplicationClient returns a client for the OauthApplication from the given config.
func NewOauthApplicationClient(c config) *OauthApplicationClient {
	return &OauthApplicationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthapplication.Hooks(f(g(h())))`.
func (c *OauthApplicationClient) Use(hooks ...Hook) {
	c.hooks.OauthApplication = append(c.hooks.OauthApplication, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthapplication.Intercept(f(g(h())))`.
func (c *OauthApplicationClient) Intercept(interceptors ...Interceptor) {
	c.inters.OauthApplication = append(c.inters.OauthApplication, interceptors...)
}

// Create returns a builder for creating a OauthApplication entity.
func (c *OauthApplicationClient) Create() *OauthApplicationCreate {
	mutation := newOauthApplicationMutation(c.config, OpCreate)
	return &OauthApplicationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OauthApplication entities.
func (c *OauthApplicationClient) CreateBulk(builders ...*OauthApplicationCreate) *OauthApplicationCreateBulk {
	return &OauthApplicationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OauthApplicationClient) MapCreateBulk(slice any, setFunc func(*OauthApplicationCreate, int)) *OauthApplicationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OauthApplicationCreateBulk{err: fmt.Errorf("calling to OauthApplicationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OauthApplicationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OauthApplicationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OauthApplication.
func (c *OauthApplicationClient) Update() *OauthApplicationUpdate {
	mutation := newOauthApplicationMutation(c.config, OpUpdate)
	return &OauthApplicationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OauthApplicationClient) UpdateOne(_m *OauthApplication) *OauthApplicationUpdateOne {
	mutation := newOauthApplicationMutation(c.config, OpUpdateOne, withOauthApplication(_m))
	return &OauthApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OauthApplicationClient) UpdateOneID(id uint64) *OauthApplicationUpdateOne {
	mutation := newOauthApplicationMutation(c.config, OpUpdateOne, withOauthApplicationID(id))
	return &OauthApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OauthApplication.
func (c *OauthApplicationClient) Delete() *OauthApplicationDelete {
	mutation := newOauthApplicationMutation(c.config, OpDelete)
	return &OauthApplicationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OauthApplicationClient) DeleteOne(_m *OauthApplication) *OauthApplicationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OauthApplicationClient) DeleteOneID(id uint64) *OauthApplicationDeleteOne {
	builder := c.Delete().Where(oauthapplication.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OauthApplicationDeleteOne{builder}
}

// Query returns a query builder for OauthApplication.
func (c *OauthApplicationClient) Query() *OauthApplicationQuery {
	return &OauthApplicationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOauthApplication},
		inters: c.Interceptors(),
	}
}

// Get returns a OauthApplication entity by its id.
func (c *OauthApplicationClient) Get(ctx context.Context, id uint64) (*OauthApplication, error) {
	return c.Query().Where(oauthapplication.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OauthApplicationClient) GetX(ctx context.Context, id uint64) *OauthApplication {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthorizationCodes queries the authorization_codes edge of a OauthApplication.
func (c *OauthApplicationClient) QueryAuthorizationCodes(_m *OauthApplication) *OauthAuthorizationCodeQuery {
	query := (&OauthAuthorizationCodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthapplication.Table, oauthapplication.FieldID, id),
			sqlgraph.To(oauthauthorizationcode.Table, oauthauthorizationcode.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oauthapplication.AuthorizationCodesTable, oauthapplication.AuthorizationCodesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTokens queries the tokens edge of a OauthApplication.
func (c *OauthApplicationClient) QueryTokens(_m *OauthApplication) *OauthTokenQuery {
	query := (&OauthTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthapplication.Table, oauthapplication.FieldID, id),
			sqlgraph.To(oauthtoken.Table, oauthtoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oauthapplication.TokensTable, oauthapplication.TokensColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserAuthorizations queries the user_authorizations edge of a OauthApplication.
func (c *OauthApplicationClient) QueryUserAuthorizations(_m *OauthApplication) *OauthUserAuthorizationQuery {
	query := (&OauthUserAuthorizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthapplication.Table, oauthapplication.FieldID, id),
			sqlgraph.To(oauthuserauthorization.Table, oauthuserauthorization.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oauthapplication.UserAuthorizationsTable, oauthapplication.UserAuthorizationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OauthApplicationClient) Hooks() []Hook {
	hooks := c.hooks.OauthApplication
	return append(hooks[:len(hooks):len(hooks)], oauthapplication.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OauthApplicationClient) Interceptors() []Interceptor {
	inters := c.inters.OauthApplication
	return append(inters[:len(inters):len(inters)], oauthapplication.Interceptors[:]...)
}

func (c *OauthApplicationClient) mutate(ctx context.Context, m *OauthApplicationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OauthApplicationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OauthApplicationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OauthApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OauthApplicationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OauthApplication mutation op: %q", m.Op())
	}
}

// OauthAuthorizationCodeClient is a client for the OauthAuthorizationCode schema.
type OauthAuthorizationCodeClient struct {
	config
}

// NewOauthAuthorizationCodeClient returns a client for the OauthAuthorizationCode from the given config.
func NewOauthAuthorizationCodeClient(c config) *OauthAuthorizationCodeClient {
	return &OauthAuthorizationCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthauthorizationcode.Hooks(f(g(h())))`.
func (c *OauthAuthorizationCodeClient) Use(hooks ...Hook) {
	c.hooks.OauthAuthorizationCode = append(c.hooks.OauthAuthorizationCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthauthorizationcode.Intercept(f(g(h())))`.
func (c *OauthAuthorizationCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.OauthAuthorizationCode = append(c.inters.OauthAuthorizationCode, interceptors...)
}

// Create returns a builder for creating a OauthAuthorizationCode entity.
func (c *OauthAuthorizationCodeClient) Create() *OauthAuthorizationCodeCreate {
	mutation := newOauthAuthorizationCodeMutation(c.config, OpCreate)
	return &OauthAuthorizationCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OauthAuthorizationCode entities.
func (c *OauthAuthorizationCodeClient) CreateBulk(builders ...*OauthAuthorizationCodeCreate) *OauthAuthorizationCodeCreateBulk {
	return &OauthAuthorizationCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OauthAuthorizationCodeClient) MapCreateBulk(slice any, setFunc func(*OauthAuthorizationCodeCreate, int)) *OauthAuthorizationCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OauthAuthorizationCodeCreateBulk{err: fmt.Errorf("calling to OauthAuthorizationCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OauthAuthorizationCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OauthAuthorizationCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OauthAuthorizationCode.
func (c *OauthAuthorizationCodeClient) Update() *OauthAuthorizationCodeUpdate {
	mutation := newOauthAuthorizationCodeMutation(c.config, OpUpdate)
	return &OauthAuthorizationCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OauthAuthorizationCodeClient) UpdateOne(_m *OauthAuthorizationCode) *OauthAuthorizationCodeUpdateOne {
	mutation := newOauthAuthorizationCodeMutation(c.config, OpUpdateOne, withOauthAuthorizationCode(_m))
	return &OauthAuthorizationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OauthAuthorizationCodeClient) UpdateOneID(id uint64) *OauthAuthorizationCodeUpdateOne {
	mutation := newOauthAuthorizationCodeMutation(c.config, OpUpdateOne, withOauthAuthorizationCodeID(id))
	return &OauthAuthorizationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OauthAuthorizationCode.
func (c *OauthAuthorizationCodeClient) Delete() *OauthAuthorizationCodeDelete {
	mutation := newOauthAuthorizationCodeMutation(c.config, OpDelete)
	return &OauthAuthorizationCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OauthAuthorizationCodeClient) DeleteOne(_m *OauthAuthorizationCode) *OauthAuthorizationCodeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OauthAuthorizationCodeClient) DeleteOneID(id uint64) *OauthAuthorizationCodeDeleteOne {
	builder := c.Delete().Where(oauthauthorizationcode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OauthAuthorizationCodeDeleteOne{builder}
}

// Query returns a query builder for OauthAuthorizationCode.
func (c *OauthAuthorizationCodeClient) Query() *OauthAuthorizationCodeQuery {
	return &OauthAuthorizationCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOauthAuthorizationCode},
		inters: c.Interceptors(),
	}
}

// Get returns a OauthAuthorizationCode entity by its id.
func (c *OauthAuthorizationCodeClient) Get(ctx context.Context, id uint64) (*OauthAuthorizationCode, error) {
	return c.Query().Where(oauthauthorizationcode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OauthAuthorizationCodeClient) GetX(ctx context.Context, id uint64) *OauthAuthorizationCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApplication queries the application edge of a OauthAuthorizationCode.
func (c *OauthAuthorizationCodeClient) QueryApplication(_m *OauthAuthorizationCode) *OauthApplicationQuery {
	query := (&OauthApplicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthauthorizationcode.Table, oauthauthorizationcode.FieldID, id),
			sqlgraph.To(oauthapplication.Table, oauthapplication.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oauthauthorizationcode.ApplicationTable, oauthauthorizationcode.ApplicationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a OauthAuthorizationCode.
func (c *OauthAuthorizationCodeClient) QueryUser(_m *OauthAuthorizationCode) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthauthorizationcode.Table, oauthauthorizationcode.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oauthauthorizationcode.UserTable, oauthauthorizationcode.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryToken queries the token edge of a OauthAuthorizationCode.
func (c *OauthAuthorizationCodeClient) QueryToken(_m *OauthAuthorizationCode) *OauthTokenQuery {
	query := (&OauthTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthauthorizationcode.Table, oauthauthorizationcode.FieldID, id),
			sqlgraph.To(oauthtoken.Table, oauthtoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, oauthauthorizationcode.TokenTable, oauthauthorizationcode.TokenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserAuthorization queries the user_authorization edge of a OauthAuthorizationCode.
func (c *OauthAuthorizationCodeClient) QueryUserAuthorization(_m *OauthAuthorizationCode) *OauthUserAuthorizationQuery {
	query := (&OauthUserAuthorizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthauthorizationcode.Table, oauthauthorizationcode.FieldID, id),
			sqlgraph.To(oauthuserauthorization.Table, oauthuserauthorization.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, oauthauthorizationcode.UserAuthorizationTable, oauthauthorizationcode.UserAuthorizationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OauthAuthorizationCodeClient) Hooks() []Hook {
	hooks := c.hooks.OauthAuthorizationCode
	return append(hooks[:len(hooks):len(hooks)], oauthauthorizationcode.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OauthAuthorizationCodeClient) Interceptors() []Interceptor {
	inters := c.inters.OauthAuthorizationCode
	return append(inters[:len(inters):len(inters)], oauthauthorizationcode.Interceptors[:]...)
}

func (c *OauthAuthorizationCodeClient) mutate(ctx context.Context, m *OauthAuthorizationCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OauthAuthorizationCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OauthAuthorizationCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OauthAuthorizationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OauthAuthorizationCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OauthAuthorizationCode mutation op: %q", m.Op())
	}
}

// OauthProviderClient is a client for the OauthProvider schema.
type OauthProviderClient struct {
	config
}

// NewOauthProviderClient returns a client for the OauthProvider from the given config.
func NewOauthProviderClient(c config) *OauthProviderClient {
	return &OauthProviderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthprovider.Hooks(f(g(h())))`.
func (c *OauthProviderClient) Use(hooks ...Hook) {
	c.hooks.OauthProvider = append(c.hooks.OauthProvider, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthprovider.Intercept(f(g(h())))`.
func (c *OauthProviderClient) Intercept(interceptors ...Interceptor) {
	c.inters.OauthProvider = append(c.inters.OauthProvider, interceptors...)
}

// Create returns a builder for creating a OauthProvider entity.
func (c *OauthProviderClient) Create() *OauthProviderCreate {
	mutation := newOauthProviderMutation(c.config, OpCreate)
	return &OauthProviderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OauthProvider entities.
func (c *OauthProviderClient) CreateBulk(builders ...*OauthProviderCreate) *OauthProviderCreateBulk {
	return &OauthProviderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OauthProviderClient) MapCreateBulk(slice any, setFunc func(*OauthProviderCreate, int)) *OauthProviderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OauthProviderCreateBulk{err: fmt.Errorf("calling to OauthProviderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OauthProviderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OauthProviderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OauthProvider.
func (c *OauthProviderClient) Update() *OauthProviderUpdate {
	mutation := newOauthProviderMutation(c.config, OpUpdate)
	return &OauthProviderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OauthProviderClient) UpdateOne(_m *OauthProvider) *OauthProviderUpdateOne {
	mutation := newOauthProviderMutation(c.config, OpUpdateOne, withOauthProvider(_m))
	return &OauthProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OauthProviderClient) UpdateOneID(id uint64) *OauthProviderUpdateOne {
	mutation := newOauthProviderMutation(c.config, OpUpdateOne, withOauthProviderID(id))
	return &OauthProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OauthProvider.
func (c *OauthProviderClient) Delete() *OauthProviderDelete {
	mutation := newOauthProviderMutation(c.config, OpDelete)
	return &OauthProviderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OauthProviderClient) DeleteOne(_m *OauthProvider) *OauthProviderDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OauthProviderClient) DeleteOneID(id uint64) *OauthProviderDeleteOne {
	builder := c.Delete().Where(oauthprovider.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OauthProviderDeleteOne{builder}
}

// Query returns a query builder for OauthProvider.
func (c *OauthProviderClient) Query() *OauthProviderQuery {
	return &OauthProviderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOauthProvider},
		inters: c.Interceptors(),
	}
}

// Get returns a OauthProvider entity by its id.
func (c *OauthProviderClient) Get(ctx context.Context, id uint64) (*OauthProvider, error) {
	return c.Query().Where(oauthprovider.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OauthProviderClient) GetX(ctx context.Context, id uint64) *OauthProvider {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStates queries the states edge of a OauthProvider.
func (c *OauthProviderClient) QueryStates(_m *OauthProvider) *OauthStateQuery {
	query := (&OauthStateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthprovider.Table, oauthprovider.FieldID, id),
			sqlgraph.To(oauthstate.Table, oauthstate.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oauthprovider.StatesTable, oauthprovider.StatesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOauthUsers queries the oauth_users edge of a OauthProvider.
func (c *OauthProviderClient) QueryOauthUsers(_m *OauthProvider) *OauthUserQuery {
	query := (&OauthUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthprovider.Table, oauthprovider.FieldID, id),
			sqlgraph.To(oauthuser.Table, oauthuser.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oauthprovider.OauthUsersTable, oauthprovider.OauthUsersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OauthProviderClient) Hooks() []Hook {
	hooks := c.hooks.OauthProvider
	return append(hooks[:len(hooks):len(hooks)], oauthprovider.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OauthProviderClient) Interceptors() []Interceptor {
	inters := c.inters.OauthProvider
	return append(inters[:len(inters):len(inters)], oauthprovider.Interceptors[:]...)
}

func (c *OauthProviderClient) mutate(ctx context.Context, m *OauthProviderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OauthProviderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OauthProviderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OauthProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OauthProviderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OauthProvider mutation op: %q", m.Op())
	}
}

// OauthStateClient is a client for the OauthState schema.
type OauthStateClient struct {
	config
}

// NewOauthStateClient returns a client for the OauthState from the given config.
func NewOauthStateClient(c config) *OauthStateClient {
	return &OauthStateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthstate.Hooks(f(g(h())))`.
func (c *OauthStateClient) Use(hooks ...Hook) {
	c.hooks.OauthState = append(c.hooks.OauthState, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthstate.Intercept(f(g(h())))`.
func (c *OauthStateClient) Intercept(interceptors ...Interceptor) {
	c.inters.OauthState = append(c.inters.OauthState, interceptors...)
}

// Create returns a builder for creating a OauthState entity.
func (c *OauthStateClient) Create() *OauthStateCreate {
	mutation := newOauthStateMutation(c.config, OpCreate)
	return &OauthStateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OauthState entities.
func (c *OauthStateClient) CreateBulk(builders ...*OauthStateCreate) *OauthStateCreateBulk {
	return &OauthStateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OauthStateClient) MapCreateBulk(slice any, setFunc func(*OauthStateCreate, int)) *OauthStateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OauthStateCreateBulk{err: fmt.Errorf("calling to OauthStateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OauthStateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OauthStateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OauthState.
func (c *OauthStateClient) Update() *OauthStateUpdate {
	mutation := newOauthStateMutation(c.config, OpUpdate)
	return &OauthStateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OauthStateClient) UpdateOne(_m *OauthState) *OauthStateUpdateOne {
	mutation := newOauthStateMutation(c.config, OpUpdateOne, withOauthState(_m))
	return &OauthStateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OauthStateClient) UpdateOneID(id uint64) *OauthStateUpdateOne {
	mutation := newOauthStateMutation(c.config, OpUpdateOne, withOauthStateID(id))
	return &OauthStateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OauthState.
func (c *OauthStateClient) Delete() *OauthStateDelete {
	mutation := newOauthStateMutation(c.config, OpDelete)
	return &OauthStateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OauthStateClient) DeleteOne(_m *OauthState) *OauthStateDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OauthStateClient) DeleteOneID(id uint64) *OauthStateDeleteOne {
	builder := c.Delete().Where(oauthstate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OauthStateDeleteOne{builder}
}

// Query returns a query builder for OauthState.
func (c *OauthStateClient) Query() *OauthStateQuery {
	return &OauthStateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOauthState},
		inters: c.Interceptors(),
	}
}

// Get returns a OauthState entity by its id.
func (c *OauthStateClient) Get(ctx context.Context, id uint64) (*OauthState, error) {
	return c.Query().Where(oauthstate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OauthStateClient) GetX(ctx context.Context, id uint64) *OauthState {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProvider queries the provider edge of a OauthState.
func (c *OauthStateClient) QueryProvider(_m *OauthState) *OauthProviderQuery {
	query := (&OauthProviderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthstate.Table, oauthstate.FieldID, id),
			sqlgraph.To(oauthprovider.Table, oauthprovider.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oauthstate.ProviderTable, oauthstate.ProviderColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a OauthState.
func (c *OauthStateClient) QueryUser(_m *OauthState) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthstate.Table, oauthstate.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oauthstate.UserTable, oauthstate.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOauthUsers queries the oauth_users edge of a OauthState.
func (c *OauthStateClient) QueryOauthUsers(_m *OauthState) *OauthUserQuery {
	query := (&OauthUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthstate.Table, oauthstate.FieldID, id),
			sqlgraph.To(oauthuser.Table, oauthuser.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, oauthstate.OauthUsersTable, oauthstate.OauthUsersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OauthStateClient) Hooks() []Hook {
	hooks := c.hooks.OauthState
	return append(hooks[:len(hooks):len(hooks)], oauthstate.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OauthStateClient) Interceptors() []Interceptor {
	inters := c.inters.OauthState
	return append(inters[:len(inters):len(inters)], oauthstate.Interceptors[:]...)
}

func (c *OauthStateClient) mutate(ctx context.Context, m *OauthStateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OauthStateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OauthStateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OauthStateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OauthStateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OauthState mutation op: %q", m.Op())
	}
}

// OauthTokenClient is a client for the OauthToken schema.
type OauthTokenClient struct {
	config
}

// NewOauthTokenClient returns a client for the OauthToken from the given config.
func NewOauthTokenClient(c config) *OauthTokenClient {
	return &OauthTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthtoken.Hooks(f(g(h())))`.
func (c *OauthTokenClient) Use(hooks ...Hook) {
	c.hooks.OauthToken = append(c.hooks.OauthToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthtoken.Intercept(f(g(h())))`.
func (c *OauthTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.OauthToken = append(c.inters.OauthToken, interceptors...)
}

// Create returns a builder for creating a OauthToken entity.
func (c *OauthTokenClient) Create() *OauthTokenCreate {
	mutation := newOauthTokenMutation(c.config, OpCreate)
	return &OauthTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OauthToken entities.
func (c *OauthTokenClient) CreateBulk(builders ...*OauthTokenCreate) *OauthTokenCreateBulk {
	return &OauthTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OauthTokenClient) MapCreateBulk(slice any, setFunc func(*OauthTokenCreate, int)) *OauthTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OauthTokenCreateBulk{err: fmt.Errorf("calling to OauthTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OauthTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OauthTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OauthToken.
func (c *OauthTokenClient) Update() *OauthTokenUpdate {
	mutation := newOauthTokenMutation(c.config, OpUpdate)
	return &OauthTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OauthTokenClient) UpdateOne(_m *OauthToken) *OauthTokenUpdateOne {
	mutation := newOauthTokenMutation(c.config, OpUpdateOne, withOauthToken(_m))
	return &OauthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OauthTokenClient) UpdateOneID(id uint64) *OauthTokenUpdateOne {
	mutation := newOauthTokenMutation(c.config, OpUpdateOne, withOauthTokenID(id))
	return &OauthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OauthToken.
func (c *OauthTokenClient) Delete() *OauthTokenDelete {
	mutation := newOauthTokenMutation(c.config, OpDelete)
	return &OauthTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OauthTokenClient) DeleteOne(_m *OauthToken) *OauthTokenDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OauthTokenClient) DeleteOneID(id uint64) *OauthTokenDeleteOne {
	builder := c.Delete().Where(oauthtoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OauthTokenDeleteOne{builder}
}

// Query returns a query builder for OauthToken.
func (c *OauthTokenClient) Query() *OauthTokenQuery {
	return &OauthTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOauthToken},
		inters: c.Interceptors(),
	}
}

// Get returns a OauthToken entity by its id.
func (c *OauthTokenClient) Get(ctx context.Context, id uint64) (*OauthToken, error) {
	return c.Query().Where(oauthtoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OauthTokenClient) GetX(ctx context.Context, id uint64) *OauthToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApplication queries the application edge of a OauthToken.
func (c *OauthTokenClient) QueryApplication(_m *OauthToken) *OauthApplicationQuery {
	query := (&OauthApplicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthtoken.Table, oauthtoken.FieldID, id),
			sqlgraph.To(oauthapplication.Table, oauthapplication.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oauthtoken.ApplicationTable, oauthtoken.ApplicationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a OauthToken.
func (c *OauthTokenClient) QueryUser(_m *OauthToken) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthtoken.Table, oauthtoken.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oauthtoken.UserTable, oauthtoken.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthorizationCode queries the authorization_code edge of a OauthToken.
func (c *OauthTokenClient) QueryAuthorizationCode(_m *OauthToken) *OauthAuthorizationCodeQuery {
	query := (&OauthAuthorizationCodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthtoken.Table, oauthtoken.FieldID, id),
			sqlgraph.To(oauthauthorizationcode.Table, oauthauthorizationcode.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, oauthtoken.AuthorizationCodeTable, oauthtoken.AuthorizationCodeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserAuthorization queries the user_authorization edge of a OauthToken.
func (c *OauthTokenClient) QueryUserAuthorization(_m *OauthToken) *OauthUserAuthorizationQuery {
	query := (&OauthUserAuthorizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthtoken.Table, oauthtoken.FieldID, id),
			sqlgraph.To(oauthuserauthorization.Table, oauthuserauthorization.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, oauthtoken.UserAuthorizationTable, oauthtoken.UserAuthorizationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OauthTokenClient) Hooks() []Hook {
	hooks := c.hooks.OauthToken
	return append(hooks[:len(hooks):len(hooks)], oauthtoken.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OauthTokenClient) Interceptors() []Interceptor {
	inters := c.inters.OauthToken
	return append(inters[:len(inters):len(inters)], oauthtoken.Interceptors[:]...)
}

func (c *OauthTokenClient) mutate(ctx context.Context, m *OauthTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OauthTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OauthTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OauthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OauthTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OauthToken mutation op: %q", m.Op())
	}
}

// OauthUserClient is a client for the OauthUser schema.
type OauthUserClient struct {
	config
}

// NewOauthUserClient returns a client for the OauthUser from the given config.
func NewOauthUserClient(c config) *OauthUserClient {
	return &OauthUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthuser.Hooks(f(g(h())))`.
func (c *OauthUserClient) Use(hooks ...Hook) {
	c.hooks.OauthUser = append(c.hooks.OauthUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthuser.Intercept(f(g(h())))`.
func (c *OauthUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.OauthUser = append(c.inters.OauthUser, interceptors...)
}

// Create returns a builder for creating a OauthUser entity.
func (c *OauthUserClient) Create() *OauthUserCreate {
	mutation := newOauthUserMutation(c.config, OpCreate)
	return &OauthUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OauthUser entities.
func (c *OauthUserClient) CreateBulk(builders ...*OauthUserCreate) *OauthUserCreateBulk {
	return &OauthUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OauthUserClient) MapCreateBulk(slice any, setFunc func(*OauthUserCreate, int)) *OauthUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OauthUserCreateBulk{err: fmt.Errorf("calling to OauthUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OauthUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OauthUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OauthUser.
func (c *OauthUserClient) Update() *OauthUserUpdate {
	mutation := newOauthUserMutation(c.config, OpUpdate)
	return &OauthUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OauthUserClient) UpdateOne(_m *OauthUser) *OauthUserUpdateOne {
	mutation := newOauthUserMutation(c.config, OpUpdateOne, withOauthUser(_m))
	return &OauthUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OauthUserClient) UpdateOneID(id uint64) *OauthUserUpdateOne {
	mutation := newOauthUserMutation(c.config, OpUpdateOne, withOauthUserID(id))
	return &OauthUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OauthUser.
func (c *OauthUserClient) Delete() *OauthUserDelete {
	mutation := newOauthUserMutation(c.config, OpDelete)
	return &OauthUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OauthUserClient) DeleteOne(_m *OauthUser) *OauthUserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OauthUserClient) DeleteOneID(id uint64) *OauthUserDeleteOne {
	builder := c.Delete().Where(oauthuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OauthUserDeleteOne{builder}
}

// Query returns a query builder for OauthUser.
func (c *OauthUserClient) Query() *OauthUserQuery {
	return &OauthUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOauthUser},
		inters: c.Interceptors(),
	}
}

// Get returns a OauthUser entity by its id.
func (c *OauthUserClient) Get(ctx context.Context, id uint64) (*OauthUser, error) {
	return c.Query().Where(oauthuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OauthUserClient) GetX(ctx context.Context, id uint64) *OauthUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProvider queries the provider edge of a OauthUser.
func (c *OauthUserClient) QueryProvider(_m *OauthUser) *OauthProviderQuery {
	query := (&OauthProviderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthuser.Table, oauthuser.FieldID, id),
			sqlgraph.To(oauthprovider.Table, oauthprovider.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oauthuser.ProviderTable, oauthuser.ProviderColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a OauthUser.
func (c *OauthUserClient) QueryUser(_m *OauthUser) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthuser.Table, oauthuser.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oauthuser.UserTable, oauthuser.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryState queries the state edge of a OauthUser.
func (c *OauthUserClient) QueryState(_m *OauthUser) *OauthStateQuery {
	query := (&OauthStateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthuser.Table, oauthuser.FieldID, id),
			sqlgraph.To(oauthstate.Table, oauthstate.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oauthuser.StateTable, oauthuser.StateColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OauthUserClient) Hooks() []Hook {
	hooks := c.hooks.OauthUser
	return append(hooks[:len(hooks):len(hooks)], oauthuser.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OauthUserClient) Interceptors() []Interceptor {
	inters := c.inters.OauthUser
	return append(inters[:len(inters):len(inters)], oauthuser.Interceptors[:]...)
}

func (c *OauthUserClient) mutate(ctx context.Context, m *OauthUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OauthUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OauthUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OauthUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OauthUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OauthUser mutation op: %q", m.Op())
	}
}

// OauthUserAuthorizationClient is a client for the OauthUserAuthorization schema.
type OauthUserAuthorizationClient struct {
	config
}

// NewOauthUserAuthorizationClient returns a client for the OauthUserAuthorization from the given config.
func NewOauthUserAuthorizationClient(c config) *OauthUserAuthorizationClient {
	return &OauthUserAuthorizationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthuserauthorization.Hooks(f(g(h())))`.
func (c *OauthUserAuthorizationClient) Use(hooks ...Hook) {
	c.hooks.OauthUserAuthorization = append(c.hooks.OauthUserAuthorization, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthuserauthorization.Intercept(f(g(h())))`.
func (c *OauthUserAuthorizationClient) Intercept(interceptors ...Interceptor) {
	c.inters.OauthUserAuthorization = append(c.inters.OauthUserAuthorization, interceptors...)
}

// Create returns a builder for creating a OauthUserAuthorization entity.
func (c *OauthUserAuthorizationClient) Create() *OauthUserAuthorizationCreate {
	mutation := newOauthUserAuthorizationMutation(c.config, OpCreate)
	return &OauthUserAuthorizationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OauthUserAuthorization entities.
func (c *OauthUserAuthorizationClient) CreateBulk(builders ...*OauthUserAuthorizationCreate) *OauthUserAuthorizationCreateBulk {
	return &OauthUserAuthorizationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OauthUserAuthorizationClient) MapCreateBulk(slice any, setFunc func(*OauthUserAuthorizationCreate, int)) *OauthUserAuthorizationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OauthUserAuthorizationCreateBulk{err: fmt.Errorf("calling to OauthUserAuthorizationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OauthUserAuthorizationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OauthUserAuthorizationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OauthUserAuthorization.
func (c *OauthUserAuthorizationClient) Update() *OauthUserAuthorizationUpdate {
	mutation := newOauthUserAuthorizationMutation(c.config, OpUpdate)
	return &OauthUserAuthorizationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OauthUserAuthorizationClient) UpdateOne(_m *OauthUserAuthorization) *OauthUserAuthorizationUpdateOne {
	mutation := newOauthUserAuthorizationMutation(c.config, OpUpdateOne, withOauthUserAuthorization(_m))
	return &OauthUserAuthorizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OauthUserAuthorizationClient) UpdateOneID(id uint64) *OauthUserAuthorizationUpdateOne {
	mutation := newOauthUserAuthorizationMutation(c.config, OpUpdateOne, withOauthUserAuthorizationID(id))
	return &OauthUserAuthorizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OauthUserAuthorization.
func (c *OauthUserAuthorizationClient) Delete() *OauthUserAuthorizationDelete {
	mutation := newOauthUserAuthorizationMutation(c.config, OpDelete)
	return &OauthUserAuthorizationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OauthUserAuthorizationClient) DeleteOne(_m *OauthUserAuthorization) *OauthUserAuthorizationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OauthUserAuthorizationClient) DeleteOneID(id uint64) *OauthUserAuthorizationDeleteOne {
	builder := c.Delete().Where(oauthuserauthorization.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OauthUserAuthorizationDeleteOne{builder}
}

// Query returns a query builder for OauthUserAuthorization.
func (c *OauthUserAuthorizationClient) Query() *OauthUserAuthorizationQuery {
	return &OauthUserAuthorizationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOauthUserAuthorization},
		inters: c.Interceptors(),
	}
}

// Get returns a OauthUserAuthorization entity by its id.
func (c *OauthUserAuthorizationClient) Get(ctx context.Context, id uint64) (*OauthUserAuthorization, error) {
	return c.Query().Where(oauthuserauthorization.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OauthUserAuthorizationClient) GetX(ctx context.Context, id uint64) *OauthUserAuthorization {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a OauthUserAuthorization.
func (c *OauthUserAuthorizationClient) QueryUser(_m *OauthUserAuthorization) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthuserauthorization.Table, oauthuserauthorization.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oauthuserauthorization.UserTable, oauthuserauthorization.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApplication queries the application edge of a OauthUserAuthorization.
func (c *OauthUserAuthorizationClient) QueryApplication(_m *OauthUserAuthorization) *OauthApplicationQuery {
	query := (&OauthApplicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthuserauthorization.Table, oauthuserauthorization.FieldID, id),
			sqlgraph.To(oauthapplication.Table, oauthapplication.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, oauthuserauthorization.ApplicationTable, oauthuserauthorization.ApplicationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCode queries the code edge of a OauthUserAuthorization.
func (c *OauthUserAuthorizationClient) QueryCode(_m *OauthUserAuthorization) *OauthAuthorizationCodeQuery {
	query := (&OauthAuthorizationCodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthuserauthorization.Table, oauthuserauthorization.FieldID, id),
			sqlgraph.To(oauthauthorizationcode.Table, oauthauthorizationcode.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, oauthuserauthorization.CodeTable, oauthuserauthorization.CodeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryToken queries the token edge of a OauthUserAuthorization.
func (c *OauthUserAuthorizationClient) QueryToken(_m *OauthUserAuthorization) *OauthTokenQuery {
	query := (&OauthTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthuserauthorization.Table, oauthuserauthorization.FieldID, id),
			sqlgraph.To(oauthtoken.Table, oauthtoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, oauthuserauthorization.TokenTable, oauthuserauthorization.TokenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OauthUserAuthorizationClient) Hooks() []Hook {
	hooks := c.hooks.OauthUserAuthorization
	return append(hooks[:len(hooks):len(hooks)], oauthuserauthorization.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OauthUserAuthorizationClient) Interceptors() []Interceptor {
	inters := c.inters.OauthUserAuthorization
	return append(inters[:len(inters):len(inters)], oauthuserauthorization.Interceptors[:]...)
}

func (c *OauthUserAuthorizationClient) mutate(ctx context.Context, m *OauthUserAuthorizationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OauthUserAuthorizationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OauthUserAuthorizationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OauthUserAuthorizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OauthUserAuthorizationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OauthUserAuthorization mutation op: %q", m.Op())
	}
}

// PermissionClient is a client for the Permission schema.
type PermissionClient struct {
	config
}

// NewPermissionClient returns a client for the Permission from the given config.
func NewPermissionClient(c config) *PermissionClient {
	return &PermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `permission.Hooks(f(g(h())))`.
func (c *PermissionClient) Use(hooks ...Hook) {
	c.hooks.Permission = append(c.hooks.Permission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `permission.Intercept(f(g(h())))`.
func (c *PermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Permission = append(c.inters.Permission, interceptors...)
}

// Create returns a builder for creating a Permission entity.
func (c *PermissionClient) Create() *PermissionCreate {
	mutation := newPermissionMutation(c.config, OpCreate)
	return &PermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Permission entities.
func (c *PermissionClient) CreateBulk(builders ...*PermissionCreate) *PermissionCreateBulk {
	return &PermissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PermissionClient) MapCreateBulk(slice any, setFunc func(*PermissionCreate, int)) *PermissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PermissionCreateBulk{err: fmt.Errorf("calling to PermissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PermissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Permission.
func (c *PermissionClient) Update() *PermissionUpdate {
	mutation := newPermissionMutation(c.config, OpUpdate)
	return &PermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PermissionClient) UpdateOne(_m *Permission) *PermissionUpdateOne {
	mutation := newPermissionMutation(c.config, OpUpdateOne, withPermission(_m))
	return &PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PermissionClient) UpdateOneID(id uint64) *PermissionUpdateOne {
	mutation := newPermissionMutation(c.config, OpUpdateOne, withPermissionID(id))
	return &PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Permission.
func (c *PermissionClient) Delete() *PermissionDelete {
	mutation := newPermissionMutation(c.config, OpDelete)
	return &PermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PermissionClient) DeleteOne(_m *Permission) *PermissionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PermissionClient) DeleteOneID(id uint64) *PermissionDeleteOne {
	builder := c.Delete().Where(permission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PermissionDeleteOne{builder}
}

// Query returns a query builder for Permission.
func (c *PermissionClient) Query() *PermissionQuery {
	return &PermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePermission},
		inters: c.Interceptors(),
	}
}

// Get returns a Permission entity by its id.
func (c *PermissionClient) Get(ctx context.Context, id uint64) (*Permission, error) {
	return c.Query().Where(permission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PermissionClient) GetX(ctx context.Context, id uint64) *Permission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRolePermissions queries the role_permissions edge of a Permission.
func (c *PermissionClient) QueryRolePermissions(_m *Permission) *RolePermissionQuery {
	query := (&RolePermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(permission.Table, permission.FieldID, id),
			sqlgraph.To(rolepermission.Table, rolepermission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, permission.RolePermissionsTable, permission.RolePermissionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScope queries the scope edge of a Permission.
func (c *PermissionClient) QueryScope(_m *Permission) *ScopeQuery {
	query := (&ScopeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(permission.Table, permission.FieldID, id),
			sqlgraph.To(scope.Table, scope.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, permission.ScopeTable, permission.ScopeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAPIAuths queries the api_auths edge of a Permission.
func (c *PermissionClient) QueryAPIAuths(_m *Permission) *APIAuthQuery {
	query := (&APIAuthClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(permission.Table, permission.FieldID, id),
			sqlgraph.To(apiauth.Table, apiauth.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, permission.APIAuthsTable, permission.APIAuthsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PermissionClient) Hooks() []Hook {
	hooks := c.hooks.Permission
	return append(hooks[:len(hooks):len(hooks)], permission.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PermissionClient) Interceptors() []Interceptor {
	inters := c.inters.Permission
	return append(inters[:len(inters):len(inters)], permission.Interceptors[:]...)
}

func (c *PermissionClient) mutate(ctx context.Context, m *PermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Permission mutation op: %q", m.Op())
	}
}

// RoleClient is a client for the Role schema.
type RoleClient struct {
	config
}

// NewRoleClient returns a client for the Role from the given config.
func NewRoleClient(c config) *RoleClient {
	return &RoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role.Hooks(f(g(h())))`.
func (c *RoleClient) Use(hooks ...Hook) {
	c.hooks.Role = append(c.hooks.Role, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `role.Intercept(f(g(h())))`.
func (c *RoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Role = append(c.inters.Role, interceptors...)
}

// Create returns a builder for creating a Role entity.
func (c *RoleClient) Create() *RoleCreate {
	mutation := newRoleMutation(c.config, OpCreate)
	return &RoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Role entities.
func (c *RoleClient) CreateBulk(builders ...*RoleCreate) *RoleCreateBulk {
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoleClient) MapCreateBulk(slice any, setFunc func(*RoleCreate, int)) *RoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoleCreateBulk{err: fmt.Errorf("calling to RoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Role.
func (c *RoleClient) Update() *RoleUpdate {
	mutation := newRoleMutation(c.config, OpUpdate)
	return &RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleClient) UpdateOne(_m *Role) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRole(_m))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleClient) UpdateOneID(id uint64) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRoleID(id))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role.
func (c *RoleClient) Delete() *RoleDelete {
	mutation := newRoleMutation(c.config, OpDelete)
	return &RoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleClient) DeleteOne(_m *Role) *RoleDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleClient) DeleteOneID(id uint64) *RoleDeleteOne {
	builder := c.Delete().Where(role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleDeleteOne{builder}
}

// Query returns a query builder for Role.
func (c *RoleClient) Query() *RoleQuery {
	return &RoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRole},
		inters: c.Interceptors(),
	}
}

// Get returns a Role entity by its id.
func (c *RoleClient) Get(ctx context.Context, id uint64) (*Role, error) {
	return c.Query().Where(role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleClient) GetX(ctx context.Context, id uint64) *Role {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserRoles queries the user_roles edge of a Role.
func (c *RoleClient) QueryUserRoles(_m *Role) *UserRoleQuery {
	query := (&UserRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(userrole.Table, userrole.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, role.UserRolesTable, role.UserRolesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRolePermissions queries the role_permissions edge of a Role.
func (c *RoleClient) QueryRolePermissions(_m *Role) *RolePermissionQuery {
	query := (&RolePermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(rolepermission.Table, rolepermission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, role.RolePermissionsTable, role.RolePermissionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInheritedBy queries the inherited_by edge of a Role.
func (c *RoleClient) QueryInheritedBy(_m *Role) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, role.InheritedByTable, role.InheritedByPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInheritsFrom queries the inherits_from edge of a Role.
func (c *RoleClient) QueryInheritsFrom(_m *Role) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, role.InheritsFromTable, role.InheritsFromPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClientDevice queries the client_device edge of a Role.
func (c *RoleClient) QueryClientDevice(_m *Role) *ClientDeviceQuery {
	query := (&ClientDeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(clientdevice.Table, clientdevice.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, role.ClientDeviceTable, role.ClientDevicePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoleClient) Hooks() []Hook {
	hooks := c.hooks.Role
	return append(hooks[:len(hooks):len(hooks)], role.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RoleClient) Interceptors() []Interceptor {
	inters := c.inters.Role
	return append(inters[:len(inters):len(inters)], role.Interceptors[:]...)
}

func (c *RoleClient) mutate(ctx context.Context, m *RoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Role mutation op: %q", m.Op())
	}
}

// RolePermissionClient is a client for the RolePermission schema.
type RolePermissionClient struct {
	config
}

// NewRolePermissionClient returns a client for the RolePermission from the given config.
func NewRolePermissionClient(c config) *RolePermissionClient {
	return &RolePermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rolepermission.Hooks(f(g(h())))`.
func (c *RolePermissionClient) Use(hooks ...Hook) {
	c.hooks.RolePermission = append(c.hooks.RolePermission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rolepermission.Intercept(f(g(h())))`.
func (c *RolePermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.RolePermission = append(c.inters.RolePermission, interceptors...)
}

// Create returns a builder for creating a RolePermission entity.
func (c *RolePermissionClient) Create() *RolePermissionCreate {
	mutation := newRolePermissionMutation(c.config, OpCreate)
	return &RolePermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RolePermission entities.
func (c *RolePermissionClient) CreateBulk(builders ...*RolePermissionCreate) *RolePermissionCreateBulk {
	return &RolePermissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RolePermissionClient) MapCreateBulk(slice any, setFunc func(*RolePermissionCreate, int)) *RolePermissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RolePermissionCreateBulk{err: fmt.Errorf("calling to RolePermissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RolePermissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RolePermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RolePermission.
func (c *RolePermissionClient) Update() *RolePermissionUpdate {
	mutation := newRolePermissionMutation(c.config, OpUpdate)
	return &RolePermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RolePermissionClient) UpdateOne(_m *RolePermission) *RolePermissionUpdateOne {
	mutation := newRolePermissionMutation(c.config, OpUpdateOne, withRolePermission(_m))
	return &RolePermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RolePermissionClient) UpdateOneID(id uint64) *RolePermissionUpdateOne {
	mutation := newRolePermissionMutation(c.config, OpUpdateOne, withRolePermissionID(id))
	return &RolePermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RolePermission.
func (c *RolePermissionClient) Delete() *RolePermissionDelete {
	mutation := newRolePermissionMutation(c.config, OpDelete)
	return &RolePermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RolePermissionClient) DeleteOne(_m *RolePermission) *RolePermissionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RolePermissionClient) DeleteOneID(id uint64) *RolePermissionDeleteOne {
	builder := c.Delete().Where(rolepermission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RolePermissionDeleteOne{builder}
}

// Query returns a query builder for RolePermission.
func (c *RolePermissionClient) Query() *RolePermissionQuery {
	return &RolePermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRolePermission},
		inters: c.Interceptors(),
	}
}

// Get returns a RolePermission entity by its id.
func (c *RolePermissionClient) Get(ctx context.Context, id uint64) (*RolePermission, error) {
	return c.Query().Where(rolepermission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RolePermissionClient) GetX(ctx context.Context, id uint64) *RolePermission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRole queries the role edge of a RolePermission.
func (c *RolePermissionClient) QueryRole(_m *RolePermission) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rolepermission.Table, rolepermission.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, rolepermission.RoleTable, rolepermission.RoleColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPermission queries the permission edge of a RolePermission.
func (c *RolePermissionClient) QueryPermission(_m *RolePermission) *PermissionQuery {
	query := (&PermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rolepermission.Table, rolepermission.FieldID, id),
			sqlgraph.To(permission.Table, permission.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, rolepermission.PermissionTable, rolepermission.PermissionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RolePermissionClient) Hooks() []Hook {
	hooks := c.hooks.RolePermission
	return append(hooks[:len(hooks):len(hooks)], rolepermission.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RolePermissionClient) Interceptors() []Interceptor {
	inters := c.inters.RolePermission
	return append(inters[:len(inters):len(inters)], rolepermission.Interceptors[:]...)
}

func (c *RolePermissionClient) mutate(ctx context.Context, m *RolePermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RolePermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RolePermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RolePermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RolePermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RolePermission mutation op: %q", m.Op())
	}
}

// ScanClient is a client for the Scan schema.
type ScanClient struct {
	config
}

// NewScanClient returns a client for the Scan from the given config.
func NewScanClient(c config) *ScanClient {
	return &ScanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scan.Hooks(f(g(h())))`.
func (c *ScanClient) Use(hooks ...Hook) {
	c.hooks.Scan = append(c.hooks.Scan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scan.Intercept(f(g(h())))`.
func (c *ScanClient) Intercept(interceptors ...Interceptor) {
	c.inters.Scan = append(c.inters.Scan, interceptors...)
}

// Create returns a builder for creating a Scan entity.
func (c *ScanClient) Create() *ScanCreate {
	mutation := newScanMutation(c.config, OpCreate)
	return &ScanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Scan entities.
func (c *ScanClient) CreateBulk(builders ...*ScanCreate) *ScanCreateBulk {
	return &ScanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScanClient) MapCreateBulk(slice any, setFunc func(*ScanCreate, int)) *ScanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScanCreateBulk{err: fmt.Errorf("calling to ScanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Scan.
func (c *ScanClient) Update() *ScanUpdate {
	mutation := newScanMutation(c.config, OpUpdate)
	return &ScanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScanClient) UpdateOne(_m *Scan) *ScanUpdateOne {
	mutation := newScanMutation(c.config, OpUpdateOne, withScan(_m))
	return &ScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScanClient) UpdateOneID(id uint64) *ScanUpdateOne {
	mutation := newScanMutation(c.config, OpUpdateOne, withScanID(id))
	return &ScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Scan.
func (c *ScanClient) Delete() *ScanDelete {
	mutation := newScanMutation(c.config, OpDelete)
	return &ScanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScanClient) DeleteOne(_m *Scan) *ScanDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScanClient) DeleteOneID(id uint64) *ScanDeleteOne {
	builder := c.Delete().Where(scan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScanDeleteOne{builder}
}

// Query returns a query builder for Scan.
func (c *ScanClient) Query() *ScanQuery {
	return &ScanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScan},
		inters: c.Interceptors(),
	}
}

// Get returns a Scan entity by its id.
func (c *ScanClient) Get(ctx context.Context, id uint64) (*Scan, error) {
	return c.Query().Where(scan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScanClient) GetX(ctx context.Context, id uint64) *Scan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAttachment queries the attachment edge of a Scan.
func (c *ScanClient) QueryAttachment(_m *Scan) *AttachmentQuery {
	query := (&AttachmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scan.Table, scan.FieldID, id),
			sqlgraph.To(attachment.Table, attachment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, scan.AttachmentTable, scan.AttachmentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScanClient) Hooks() []Hook {
	hooks := c.hooks.Scan
	return append(hooks[:len(hooks):len(hooks)], scan.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ScanClient) Interceptors() []Interceptor {
	inters := c.inters.Scan
	return append(inters[:len(inters):len(inters)], scan.Interceptors[:]...)
}

func (c *ScanClient) mutate(ctx context.Context, m *ScanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Scan mutation op: %q", m.Op())
	}
}

// ScopeClient is a client for the Scope schema.
type ScopeClient struct {
	config
}

// NewScopeClient returns a client for the Scope from the given config.
func NewScopeClient(c config) *ScopeClient {
	return &ScopeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scope.Hooks(f(g(h())))`.
func (c *ScopeClient) Use(hooks ...Hook) {
	c.hooks.Scope = append(c.hooks.Scope, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scope.Intercept(f(g(h())))`.
func (c *ScopeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Scope = append(c.inters.Scope, interceptors...)
}

// Create returns a builder for creating a Scope entity.
func (c *ScopeClient) Create() *ScopeCreate {
	mutation := newScopeMutation(c.config, OpCreate)
	return &ScopeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Scope entities.
func (c *ScopeClient) CreateBulk(builders ...*ScopeCreate) *ScopeCreateBulk {
	return &ScopeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScopeClient) MapCreateBulk(slice any, setFunc func(*ScopeCreate, int)) *ScopeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScopeCreateBulk{err: fmt.Errorf("calling to ScopeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScopeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScopeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Scope.
func (c *ScopeClient) Update() *ScopeUpdate {
	mutation := newScopeMutation(c.config, OpUpdate)
	return &ScopeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScopeClient) UpdateOne(_m *Scope) *ScopeUpdateOne {
	mutation := newScopeMutation(c.config, OpUpdateOne, withScope(_m))
	return &ScopeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScopeClient) UpdateOneID(id uint64) *ScopeUpdateOne {
	mutation := newScopeMutation(c.config, OpUpdateOne, withScopeID(id))
	return &ScopeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Scope.
func (c *ScopeClient) Delete() *ScopeDelete {
	mutation := newScopeMutation(c.config, OpDelete)
	return &ScopeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScopeClient) DeleteOne(_m *Scope) *ScopeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScopeClient) DeleteOneID(id uint64) *ScopeDeleteOne {
	builder := c.Delete().Where(scope.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScopeDeleteOne{builder}
}

// Query returns a query builder for Scope.
func (c *ScopeClient) Query() *ScopeQuery {
	return &ScopeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScope},
		inters: c.Interceptors(),
	}
}

// Get returns a Scope entity by its id.
func (c *ScopeClient) Get(ctx context.Context, id uint64) (*Scope, error) {
	return c.Query().Where(scope.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScopeClient) GetX(ctx context.Context, id uint64) *Scope {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParent queries the parent edge of a Scope.
func (c *ScopeClient) QueryParent(_m *Scope) *ScopeQuery {
	query := (&ScopeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scope.Table, scope.FieldID, id),
			sqlgraph.To(scope.Table, scope.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scope.ParentTable, scope.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Scope.
func (c *ScopeClient) QueryChildren(_m *Scope) *ScopeQuery {
	query := (&ScopeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scope.Table, scope.FieldID, id),
			sqlgraph.To(scope.Table, scope.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scope.ChildrenTable, scope.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPermission queries the permission edge of a Scope.
func (c *ScopeClient) QueryPermission(_m *Scope) *PermissionQuery {
	query := (&PermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scope.Table, scope.FieldID, id),
			sqlgraph.To(permission.Table, permission.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, scope.PermissionTable, scope.PermissionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScopeClient) Hooks() []Hook {
	hooks := c.hooks.Scope
	return append(hooks[:len(hooks):len(hooks)], scope.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ScopeClient) Interceptors() []Interceptor {
	inters := c.inters.Scope
	return append(inters[:len(inters):len(inters)], scope.Interceptors[:]...)
}

func (c *ScopeClient) mutate(ctx context.Context, m *ScopeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScopeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScopeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScopeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScopeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Scope mutation op: %q", m.Op())
	}
}

// StationClient is a client for the Station schema.
type StationClient struct {
	config
}

// NewStationClient returns a client for the Station from the given config.
func NewStationClient(c config) *StationClient {
	return &StationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `station.Hooks(f(g(h())))`.
func (c *StationClient) Use(hooks ...Hook) {
	c.hooks.Station = append(c.hooks.Station, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `station.Intercept(f(g(h())))`.
func (c *StationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Station = append(c.inters.Station, interceptors...)
}

// Create returns a builder for creating a Station entity.
func (c *StationClient) Create() *StationCreate {
	mutation := newStationMutation(c.config, OpCreate)
	return &StationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Station entities.
func (c *StationClient) CreateBulk(builders ...*StationCreate) *StationCreateBulk {
	return &StationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StationClient) MapCreateBulk(slice any, setFunc func(*StationCreate, int)) *StationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StationCreateBulk{err: fmt.Errorf("calling to StationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Station.
func (c *StationClient) Update() *StationUpdate {
	mutation := newStationMutation(c.config, OpUpdate)
	return &StationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StationClient) UpdateOne(_m *Station) *StationUpdateOne {
	mutation := newStationMutation(c.config, OpUpdateOne, withStation(_m))
	return &StationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StationClient) UpdateOneID(id uint64) *StationUpdateOne {
	mutation := newStationMutation(c.config, OpUpdateOne, withStationID(id))
	return &StationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Station.
func (c *StationClient) Delete() *StationDelete {
	mutation := newStationMutation(c.config, OpDelete)
	return &StationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StationClient) DeleteOne(_m *Station) *StationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StationClient) DeleteOneID(id uint64) *StationDeleteOne {
	builder := c.Delete().Where(station.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StationDeleteOne{builder}
}

// Query returns a query builder for Station.
func (c *StationClient) Query() *StationQuery {
	return &StationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStation},
		inters: c.Interceptors(),
	}
}

// Get returns a Station entity by its id.
func (c *StationClient) Get(ctx context.Context, id uint64) (*Station, error) {
	return c.Query().Where(station.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StationClient) GetX(ctx context.Context, id uint64) *Station {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArea queries the area edge of a Station.
func (c *StationClient) QueryArea(_m *Station) *AreaQuery {
	query := (&AreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(station.Table, station.FieldID, id),
			sqlgraph.To(area.Table, area.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, station.AreaTable, station.AreaColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubwayStations queries the subway_stations edge of a Station.
func (c *StationClient) QuerySubwayStations(_m *Station) *SubwayStationQuery {
	query := (&SubwayStationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(station.Table, station.FieldID, id),
			sqlgraph.To(subwaystation.Table, subwaystation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, station.SubwayStationsTable, station.SubwayStationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StationClient) Hooks() []Hook {
	hooks := c.hooks.Station
	return append(hooks[:len(hooks):len(hooks)], station.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *StationClient) Interceptors() []Interceptor {
	inters := c.inters.Station
	return append(inters[:len(inters):len(inters)], station.Interceptors[:]...)
}

func (c *StationClient) mutate(ctx context.Context, m *StationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Station mutation op: %q", m.Op())
	}
}

// SubwayClient is a client for the Subway schema.
type SubwayClient struct {
	config
}

// NewSubwayClient returns a client for the Subway from the given config.
func NewSubwayClient(c config) *SubwayClient {
	return &SubwayClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subway.Hooks(f(g(h())))`.
func (c *SubwayClient) Use(hooks ...Hook) {
	c.hooks.Subway = append(c.hooks.Subway, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subway.Intercept(f(g(h())))`.
func (c *SubwayClient) Intercept(interceptors ...Interceptor) {
	c.inters.Subway = append(c.inters.Subway, interceptors...)
}

// Create returns a builder for creating a Subway entity.
func (c *SubwayClient) Create() *SubwayCreate {
	mutation := newSubwayMutation(c.config, OpCreate)
	return &SubwayCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Subway entities.
func (c *SubwayClient) CreateBulk(builders ...*SubwayCreate) *SubwayCreateBulk {
	return &SubwayCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubwayClient) MapCreateBulk(slice any, setFunc func(*SubwayCreate, int)) *SubwayCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubwayCreateBulk{err: fmt.Errorf("calling to SubwayClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubwayCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubwayCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Subway.
func (c *SubwayClient) Update() *SubwayUpdate {
	mutation := newSubwayMutation(c.config, OpUpdate)
	return &SubwayUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubwayClient) UpdateOne(_m *Subway) *SubwayUpdateOne {
	mutation := newSubwayMutation(c.config, OpUpdateOne, withSubway(_m))
	return &SubwayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubwayClient) UpdateOneID(id uint64) *SubwayUpdateOne {
	mutation := newSubwayMutation(c.config, OpUpdateOne, withSubwayID(id))
	return &SubwayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subway.
func (c *SubwayClient) Delete() *SubwayDelete {
	mutation := newSubwayMutation(c.config, OpDelete)
	return &SubwayDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubwayClient) DeleteOne(_m *Subway) *SubwayDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubwayClient) DeleteOneID(id uint64) *SubwayDeleteOne {
	builder := c.Delete().Where(subway.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubwayDeleteOne{builder}
}

// Query returns a query builder for Subway.
func (c *SubwayClient) Query() *SubwayQuery {
	return &SubwayQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubway},
		inters: c.Interceptors(),
	}
}

// Get returns a Subway entity by its id.
func (c *SubwayClient) Get(ctx context.Context, id uint64) (*Subway, error) {
	return c.Query().Where(subway.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubwayClient) GetX(ctx context.Context, id uint64) *Subway {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArea queries the area edge of a Subway.
func (c *SubwayClient) QueryArea(_m *Subway) *AreaQuery {
	query := (&AreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subway.Table, subway.FieldID, id),
			sqlgraph.To(area.Table, area.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, subway.AreaTable, subway.AreaColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubwayStations queries the subway_stations edge of a Subway.
func (c *SubwayClient) QuerySubwayStations(_m *Subway) *SubwayStationQuery {
	query := (&SubwayStationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subway.Table, subway.FieldID, id),
			sqlgraph.To(subwaystation.Table, subwaystation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, subway.SubwayStationsTable, subway.SubwayStationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubwayClient) Hooks() []Hook {
	hooks := c.hooks.Subway
	return append(hooks[:len(hooks):len(hooks)], subway.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SubwayClient) Interceptors() []Interceptor {
	inters := c.inters.Subway
	return append(inters[:len(inters):len(inters)], subway.Interceptors[:]...)
}

func (c *SubwayClient) mutate(ctx context.Context, m *SubwayMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubwayCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubwayUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubwayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubwayDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Subway mutation op: %q", m.Op())
	}
}

// SubwayStationClient is a client for the SubwayStation schema.
type SubwayStationClient struct {
	config
}

// NewSubwayStationClient returns a client for the SubwayStation from the given config.
func NewSubwayStationClient(c config) *SubwayStationClient {
	return &SubwayStationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subwaystation.Hooks(f(g(h())))`.
func (c *SubwayStationClient) Use(hooks ...Hook) {
	c.hooks.SubwayStation = append(c.hooks.SubwayStation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subwaystation.Intercept(f(g(h())))`.
func (c *SubwayStationClient) Intercept(interceptors ...Interceptor) {
	c.inters.SubwayStation = append(c.inters.SubwayStation, interceptors...)
}

// Create returns a builder for creating a SubwayStation entity.
func (c *SubwayStationClient) Create() *SubwayStationCreate {
	mutation := newSubwayStationMutation(c.config, OpCreate)
	return &SubwayStationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SubwayStation entities.
func (c *SubwayStationClient) CreateBulk(builders ...*SubwayStationCreate) *SubwayStationCreateBulk {
	return &SubwayStationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubwayStationClient) MapCreateBulk(slice any, setFunc func(*SubwayStationCreate, int)) *SubwayStationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubwayStationCreateBulk{err: fmt.Errorf("calling to SubwayStationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubwayStationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubwayStationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SubwayStation.
func (c *SubwayStationClient) Update() *SubwayStationUpdate {
	mutation := newSubwayStationMutation(c.config, OpUpdate)
	return &SubwayStationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubwayStationClient) UpdateOne(_m *SubwayStation) *SubwayStationUpdateOne {
	mutation := newSubwayStationMutation(c.config, OpUpdateOne, withSubwayStation(_m))
	return &SubwayStationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubwayStationClient) UpdateOneID(id uint64) *SubwayStationUpdateOne {
	mutation := newSubwayStationMutation(c.config, OpUpdateOne, withSubwayStationID(id))
	return &SubwayStationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SubwayStation.
func (c *SubwayStationClient) Delete() *SubwayStationDelete {
	mutation := newSubwayStationMutation(c.config, OpDelete)
	return &SubwayStationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubwayStationClient) DeleteOne(_m *SubwayStation) *SubwayStationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubwayStationClient) DeleteOneID(id uint64) *SubwayStationDeleteOne {
	builder := c.Delete().Where(subwaystation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubwayStationDeleteOne{builder}
}

// Query returns a query builder for SubwayStation.
func (c *SubwayStationClient) Query() *SubwayStationQuery {
	return &SubwayStationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubwayStation},
		inters: c.Interceptors(),
	}
}

// Get returns a SubwayStation entity by its id.
func (c *SubwayStationClient) Get(ctx context.Context, id uint64) (*SubwayStation, error) {
	return c.Query().Where(subwaystation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubwayStationClient) GetX(ctx context.Context, id uint64) *SubwayStation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStation queries the station edge of a SubwayStation.
func (c *SubwayStationClient) QueryStation(_m *SubwayStation) *StationQuery {
	query := (&StationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subwaystation.Table, subwaystation.FieldID, id),
			sqlgraph.To(station.Table, station.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, subwaystation.StationTable, subwaystation.StationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubway queries the subway edge of a SubwayStation.
func (c *SubwayStationClient) QuerySubway(_m *SubwayStation) *SubwayQuery {
	query := (&SubwayClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subwaystation.Table, subwaystation.FieldID, id),
			sqlgraph.To(subway.Table, subway.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, subwaystation.SubwayTable, subwaystation.SubwayColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubwayStationClient) Hooks() []Hook {
	hooks := c.hooks.SubwayStation
	return append(hooks[:len(hooks):len(hooks)], subwaystation.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SubwayStationClient) Interceptors() []Interceptor {
	inters := c.inters.SubwayStation
	return append(inters[:len(inters):len(inters)], subwaystation.Interceptors[:]...)
}

func (c *SubwayStationClient) mutate(ctx context.Context, m *SubwayStationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubwayStationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubwayStationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubwayStationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubwayStationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SubwayStation mutation op: %q", m.Op())
	}
}

// SystemMonitorClient is a client for the SystemMonitor schema.
type SystemMonitorClient struct {
	config
}

// NewSystemMonitorClient returns a client for the SystemMonitor from the given config.
func NewSystemMonitorClient(c config) *SystemMonitorClient {
	return &SystemMonitorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemmonitor.Hooks(f(g(h())))`.
func (c *SystemMonitorClient) Use(hooks ...Hook) {
	c.hooks.SystemMonitor = append(c.hooks.SystemMonitor, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemmonitor.Intercept(f(g(h())))`.
func (c *SystemMonitorClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemMonitor = append(c.inters.SystemMonitor, interceptors...)
}

// Create returns a builder for creating a SystemMonitor entity.
func (c *SystemMonitorClient) Create() *SystemMonitorCreate {
	mutation := newSystemMonitorMutation(c.config, OpCreate)
	return &SystemMonitorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemMonitor entities.
func (c *SystemMonitorClient) CreateBulk(builders ...*SystemMonitorCreate) *SystemMonitorCreateBulk {
	return &SystemMonitorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemMonitorClient) MapCreateBulk(slice any, setFunc func(*SystemMonitorCreate, int)) *SystemMonitorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemMonitorCreateBulk{err: fmt.Errorf("calling to SystemMonitorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemMonitorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemMonitorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemMonitor.
func (c *SystemMonitorClient) Update() *SystemMonitorUpdate {
	mutation := newSystemMonitorMutation(c.config, OpUpdate)
	return &SystemMonitorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemMonitorClient) UpdateOne(_m *SystemMonitor) *SystemMonitorUpdateOne {
	mutation := newSystemMonitorMutation(c.config, OpUpdateOne, withSystemMonitor(_m))
	return &SystemMonitorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemMonitorClient) UpdateOneID(id uint64) *SystemMonitorUpdateOne {
	mutation := newSystemMonitorMutation(c.config, OpUpdateOne, withSystemMonitorID(id))
	return &SystemMonitorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemMonitor.
func (c *SystemMonitorClient) Delete() *SystemMonitorDelete {
	mutation := newSystemMonitorMutation(c.config, OpDelete)
	return &SystemMonitorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemMonitorClient) DeleteOne(_m *SystemMonitor) *SystemMonitorDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemMonitorClient) DeleteOneID(id uint64) *SystemMonitorDeleteOne {
	builder := c.Delete().Where(systemmonitor.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemMonitorDeleteOne{builder}
}

// Query returns a query builder for SystemMonitor.
func (c *SystemMonitorClient) Query() *SystemMonitorQuery {
	return &SystemMonitorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemMonitor},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemMonitor entity by its id.
func (c *SystemMonitorClient) Get(ctx context.Context, id uint64) (*SystemMonitor, error) {
	return c.Query().Where(systemmonitor.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemMonitorClient) GetX(ctx context.Context, id uint64) *SystemMonitor {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SystemMonitorClient) Hooks() []Hook {
	hooks := c.hooks.SystemMonitor
	return append(hooks[:len(hooks):len(hooks)], systemmonitor.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SystemMonitorClient) Interceptors() []Interceptor {
	return c.inters.SystemMonitor
}

func (c *SystemMonitorClient) mutate(ctx context.Context, m *SystemMonitorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemMonitorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemMonitorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemMonitorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemMonitorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemMonitor mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uint64) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uint64) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uint64) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uint64) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserRoles queries the user_roles edge of a User.
func (c *UserClient) QueryUserRoles(_m *User) *UserRoleQuery {
	query := (&UserRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userrole.Table, userrole.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserRolesTable, user.UserRolesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCredentials queries the credentials edge of a User.
func (c *UserClient) QueryCredentials(_m *User) *CredentialQuery {
	query := (&CredentialClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(credential.Table, credential.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CredentialsTable, user.CredentialsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLoginRecords queries the login_records edge of a User.
func (c *UserClient) QueryLoginRecords(_m *User) *LoginRecordQuery {
	query := (&LoginRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(loginrecord.Table, loginrecord.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LoginRecordsTable, user.LoginRecordsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAvatar queries the avatar edge of a User.
func (c *UserClient) QueryAvatar(_m *User) *AttachmentQuery {
	query := (&AttachmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(attachment.Table, attachment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, user.AvatarTable, user.AvatarColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	hooks := c.hooks.User
	return append(hooks[:len(hooks):len(hooks)], user.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	inters := c.inters.User
	return append(inters[:len(inters):len(inters)], user.Interceptors[:]...)
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserRoleClient is a client for the UserRole schema.
type UserRoleClient struct {
	config
}

// NewUserRoleClient returns a client for the UserRole from the given config.
func NewUserRoleClient(c config) *UserRoleClient {
	return &UserRoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userrole.Hooks(f(g(h())))`.
func (c *UserRoleClient) Use(hooks ...Hook) {
	c.hooks.UserRole = append(c.hooks.UserRole, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userrole.Intercept(f(g(h())))`.
func (c *UserRoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserRole = append(c.inters.UserRole, interceptors...)
}

// Create returns a builder for creating a UserRole entity.
func (c *UserRoleClient) Create() *UserRoleCreate {
	mutation := newUserRoleMutation(c.config, OpCreate)
	return &UserRoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserRole entities.
func (c *UserRoleClient) CreateBulk(builders ...*UserRoleCreate) *UserRoleCreateBulk {
	return &UserRoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserRoleClient) MapCreateBulk(slice any, setFunc func(*UserRoleCreate, int)) *UserRoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserRoleCreateBulk{err: fmt.Errorf("calling to UserRoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserRoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserRoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserRole.
func (c *UserRoleClient) Update() *UserRoleUpdate {
	mutation := newUserRoleMutation(c.config, OpUpdate)
	return &UserRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserRoleClient) UpdateOne(_m *UserRole) *UserRoleUpdateOne {
	mutation := newUserRoleMutation(c.config, OpUpdateOne, withUserRole(_m))
	return &UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserRoleClient) UpdateOneID(id uint64) *UserRoleUpdateOne {
	mutation := newUserRoleMutation(c.config, OpUpdateOne, withUserRoleID(id))
	return &UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserRole.
func (c *UserRoleClient) Delete() *UserRoleDelete {
	mutation := newUserRoleMutation(c.config, OpDelete)
	return &UserRoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserRoleClient) DeleteOne(_m *UserRole) *UserRoleDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserRoleClient) DeleteOneID(id uint64) *UserRoleDeleteOne {
	builder := c.Delete().Where(userrole.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserRoleDeleteOne{builder}
}

// Query returns a query builder for UserRole.
func (c *UserRoleClient) Query() *UserRoleQuery {
	return &UserRoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserRole},
		inters: c.Interceptors(),
	}
}

// Get returns a UserRole entity by its id.
func (c *UserRoleClient) Get(ctx context.Context, id uint64) (*UserRole, error) {
	return c.Query().Where(userrole.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserRoleClient) GetX(ctx context.Context, id uint64) *UserRole {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserRole.
func (c *UserRoleClient) QueryUser(_m *UserRole) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userrole.Table, userrole.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userrole.UserTable, userrole.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRole queries the role edge of a UserRole.
func (c *UserRoleClient) QueryRole(_m *UserRole) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userrole.Table, userrole.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userrole.RoleTable, userrole.RoleColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserRoleClient) Hooks() []Hook {
	hooks := c.hooks.UserRole
	return append(hooks[:len(hooks):len(hooks)], userrole.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserRoleClient) Interceptors() []Interceptor {
	inters := c.inters.UserRole
	return append(inters[:len(inters):len(inters)], userrole.Interceptors[:]...)
}

func (c *UserRoleClient) mutate(ctx context.Context, m *UserRoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserRoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserRoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserRole mutation op: %q", m.Op())
	}
}

// VerifyCodeClient is a client for the VerifyCode schema.
type VerifyCodeClient struct {
	config
}

// NewVerifyCodeClient returns a client for the VerifyCode from the given config.
func NewVerifyCodeClient(c config) *VerifyCodeClient {
	return &VerifyCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `verifycode.Hooks(f(g(h())))`.
func (c *VerifyCodeClient) Use(hooks ...Hook) {
	c.hooks.VerifyCode = append(c.hooks.VerifyCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `verifycode.Intercept(f(g(h())))`.
func (c *VerifyCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.VerifyCode = append(c.inters.VerifyCode, interceptors...)
}

// Create returns a builder for creating a VerifyCode entity.
func (c *VerifyCodeClient) Create() *VerifyCodeCreate {
	mutation := newVerifyCodeMutation(c.config, OpCreate)
	return &VerifyCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VerifyCode entities.
func (c *VerifyCodeClient) CreateBulk(builders ...*VerifyCodeCreate) *VerifyCodeCreateBulk {
	return &VerifyCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VerifyCodeClient) MapCreateBulk(slice any, setFunc func(*VerifyCodeCreate, int)) *VerifyCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VerifyCodeCreateBulk{err: fmt.Errorf("calling to VerifyCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VerifyCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VerifyCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VerifyCode.
func (c *VerifyCodeClient) Update() *VerifyCodeUpdate {
	mutation := newVerifyCodeMutation(c.config, OpUpdate)
	return &VerifyCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VerifyCodeClient) UpdateOne(_m *VerifyCode) *VerifyCodeUpdateOne {
	mutation := newVerifyCodeMutation(c.config, OpUpdateOne, withVerifyCode(_m))
	return &VerifyCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VerifyCodeClient) UpdateOneID(id uint64) *VerifyCodeUpdateOne {
	mutation := newVerifyCodeMutation(c.config, OpUpdateOne, withVerifyCodeID(id))
	return &VerifyCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VerifyCode.
func (c *VerifyCodeClient) Delete() *VerifyCodeDelete {
	mutation := newVerifyCodeMutation(c.config, OpDelete)
	return &VerifyCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VerifyCodeClient) DeleteOne(_m *VerifyCode) *VerifyCodeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VerifyCodeClient) DeleteOneID(id uint64) *VerifyCodeDeleteOne {
	builder := c.Delete().Where(verifycode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VerifyCodeDeleteOne{builder}
}

// Query returns a query builder for VerifyCode.
func (c *VerifyCodeClient) Query() *VerifyCodeQuery {
	return &VerifyCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVerifyCode},
		inters: c.Interceptors(),
	}
}

// Get returns a VerifyCode entity by its id.
func (c *VerifyCodeClient) Get(ctx context.Context, id uint64) (*VerifyCode, error) {
	return c.Query().Where(verifycode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VerifyCodeClient) GetX(ctx context.Context, id uint64) *VerifyCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VerifyCodeClient) Hooks() []Hook {
	hooks := c.hooks.VerifyCode
	return append(hooks[:len(hooks):len(hooks)], verifycode.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *VerifyCodeClient) Interceptors() []Interceptor {
	inters := c.inters.VerifyCode
	return append(inters[:len(inters):len(inters)], verifycode.Interceptors[:]...)
}

func (c *VerifyCodeClient) mutate(ctx context.Context, m *VerifyCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VerifyCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VerifyCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VerifyCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VerifyCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VerifyCode mutation op: %q", m.Op())
	}
}

// WorkflowApplicationClient is a client for the WorkflowApplication schema.
type WorkflowApplicationClient struct {
	config
}

// NewWorkflowApplicationClient returns a client for the WorkflowApplication from the given config.
func NewWorkflowApplicationClient(c config) *WorkflowApplicationClient {
	return &WorkflowApplicationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowapplication.Hooks(f(g(h())))`.
func (c *WorkflowApplicationClient) Use(hooks ...Hook) {
	c.hooks.WorkflowApplication = append(c.hooks.WorkflowApplication, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowapplication.Intercept(f(g(h())))`.
func (c *WorkflowApplicationClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowApplication = append(c.inters.WorkflowApplication, interceptors...)
}

// Create returns a builder for creating a WorkflowApplication entity.
func (c *WorkflowApplicationClient) Create() *WorkflowApplicationCreate {
	mutation := newWorkflowApplicationMutation(c.config, OpCreate)
	return &WorkflowApplicationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowApplication entities.
func (c *WorkflowApplicationClient) CreateBulk(builders ...*WorkflowApplicationCreate) *WorkflowApplicationCreateBulk {
	return &WorkflowApplicationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowApplicationClient) MapCreateBulk(slice any, setFunc func(*WorkflowApplicationCreate, int)) *WorkflowApplicationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowApplicationCreateBulk{err: fmt.Errorf("calling to WorkflowApplicationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowApplicationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowApplicationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowApplication.
func (c *WorkflowApplicationClient) Update() *WorkflowApplicationUpdate {
	mutation := newWorkflowApplicationMutation(c.config, OpUpdate)
	return &WorkflowApplicationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowApplicationClient) UpdateOne(_m *WorkflowApplication) *WorkflowApplicationUpdateOne {
	mutation := newWorkflowApplicationMutation(c.config, OpUpdateOne, withWorkflowApplication(_m))
	return &WorkflowApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowApplicationClient) UpdateOneID(id uint64) *WorkflowApplicationUpdateOne {
	mutation := newWorkflowApplicationMutation(c.config, OpUpdateOne, withWorkflowApplicationID(id))
	return &WorkflowApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowApplication.
func (c *WorkflowApplicationClient) Delete() *WorkflowApplicationDelete {
	mutation := newWorkflowApplicationMutation(c.config, OpDelete)
	return &WorkflowApplicationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowApplicationClient) DeleteOne(_m *WorkflowApplication) *WorkflowApplicationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowApplicationClient) DeleteOneID(id uint64) *WorkflowApplicationDeleteOne {
	builder := c.Delete().Where(workflowapplication.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowApplicationDeleteOne{builder}
}

// Query returns a query builder for WorkflowApplication.
func (c *WorkflowApplicationClient) Query() *WorkflowApplicationQuery {
	return &WorkflowApplicationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowApplication},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowApplication entity by its id.
func (c *WorkflowApplicationClient) Get(ctx context.Context, id uint64) (*WorkflowApplication, error) {
	return c.Query().Where(workflowapplication.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowApplicationClient) GetX(ctx context.Context, id uint64) *WorkflowApplication {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNodes queries the nodes edge of a WorkflowApplication.
func (c *WorkflowApplicationClient) QueryNodes(_m *WorkflowApplication) *WorkflowNodeQuery {
	query := (&WorkflowNodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowapplication.Table, workflowapplication.FieldID, id),
			sqlgraph.To(workflownode.Table, workflownode.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflowapplication.NodesTable, workflowapplication.NodesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEdges queries the edges edge of a WorkflowApplication.
func (c *WorkflowApplicationClient) QueryEdges(_m *WorkflowApplication) *WorkflowEdgeQuery {
	query := (&WorkflowEdgeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowapplication.Table, workflowapplication.FieldID, id),
			sqlgraph.To(workflowedge.Table, workflowedge.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflowapplication.EdgesTable, workflowapplication.EdgesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutions queries the executions edge of a WorkflowApplication.
func (c *WorkflowApplicationClient) QueryExecutions(_m *WorkflowApplication) *WorkflowExecutionQuery {
	query := (&WorkflowExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowapplication.Table, workflowapplication.FieldID, id),
			sqlgraph.To(workflowexecution.Table, workflowexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflowapplication.ExecutionsTable, workflowapplication.ExecutionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowApplicationClient) Hooks() []Hook {
	hooks := c.hooks.WorkflowApplication
	return append(hooks[:len(hooks):len(hooks)], workflowapplication.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WorkflowApplicationClient) Interceptors() []Interceptor {
	inters := c.inters.WorkflowApplication
	return append(inters[:len(inters):len(inters)], workflowapplication.Interceptors[:]...)
}

func (c *WorkflowApplicationClient) mutate(ctx context.Context, m *WorkflowApplicationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowApplicationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowApplicationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowApplicationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkflowApplication mutation op: %q", m.Op())
	}
}

// WorkflowEdgeClient is a client for the WorkflowEdge schema.
type WorkflowEdgeClient struct {
	config
}

// NewWorkflowEdgeClient returns a client for the WorkflowEdge from the given config.
func NewWorkflowEdgeClient(c config) *WorkflowEdgeClient {
	return &WorkflowEdgeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowedge.Hooks(f(g(h())))`.
func (c *WorkflowEdgeClient) Use(hooks ...Hook) {
	c.hooks.WorkflowEdge = append(c.hooks.WorkflowEdge, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowedge.Intercept(f(g(h())))`.
func (c *WorkflowEdgeClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowEdge = append(c.inters.WorkflowEdge, interceptors...)
}

// Create returns a builder for creating a WorkflowEdge entity.
func (c *WorkflowEdgeClient) Create() *WorkflowEdgeCreate {
	mutation := newWorkflowEdgeMutation(c.config, OpCreate)
	return &WorkflowEdgeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowEdge entities.
func (c *WorkflowEdgeClient) CreateBulk(builders ...*WorkflowEdgeCreate) *WorkflowEdgeCreateBulk {
	return &WorkflowEdgeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowEdgeClient) MapCreateBulk(slice any, setFunc func(*WorkflowEdgeCreate, int)) *WorkflowEdgeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowEdgeCreateBulk{err: fmt.Errorf("calling to WorkflowEdgeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowEdgeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowEdgeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowEdge.
func (c *WorkflowEdgeClient) Update() *WorkflowEdgeUpdate {
	mutation := newWorkflowEdgeMutation(c.config, OpUpdate)
	return &WorkflowEdgeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowEdgeClient) UpdateOne(_m *WorkflowEdge) *WorkflowEdgeUpdateOne {
	mutation := newWorkflowEdgeMutation(c.config, OpUpdateOne, withWorkflowEdge(_m))
	return &WorkflowEdgeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowEdgeClient) UpdateOneID(id uint64) *WorkflowEdgeUpdateOne {
	mutation := newWorkflowEdgeMutation(c.config, OpUpdateOne, withWorkflowEdgeID(id))
	return &WorkflowEdgeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowEdge.
func (c *WorkflowEdgeClient) Delete() *WorkflowEdgeDelete {
	mutation := newWorkflowEdgeMutation(c.config, OpDelete)
	return &WorkflowEdgeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowEdgeClient) DeleteOne(_m *WorkflowEdge) *WorkflowEdgeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowEdgeClient) DeleteOneID(id uint64) *WorkflowEdgeDeleteOne {
	builder := c.Delete().Where(workflowedge.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowEdgeDeleteOne{builder}
}

// Query returns a query builder for WorkflowEdge.
func (c *WorkflowEdgeClient) Query() *WorkflowEdgeQuery {
	return &WorkflowEdgeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowEdge},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowEdge entity by its id.
func (c *WorkflowEdgeClient) Get(ctx context.Context, id uint64) (*WorkflowEdge, error) {
	return c.Query().Where(workflowedge.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowEdgeClient) GetX(ctx context.Context, id uint64) *WorkflowEdge {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApplication queries the application edge of a WorkflowEdge.
func (c *WorkflowEdgeClient) QueryApplication(_m *WorkflowEdge) *WorkflowApplicationQuery {
	query := (&WorkflowApplicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowedge.Table, workflowedge.FieldID, id),
			sqlgraph.To(workflowapplication.Table, workflowapplication.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowedge.ApplicationTable, workflowedge.ApplicationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySourceNode queries the source_node edge of a WorkflowEdge.
func (c *WorkflowEdgeClient) QuerySourceNode(_m *WorkflowEdge) *WorkflowNodeQuery {
	query := (&WorkflowNodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowedge.Table, workflowedge.FieldID, id),
			sqlgraph.To(workflownode.Table, workflownode.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowedge.SourceNodeTable, workflowedge.SourceNodeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTargetNode queries the target_node edge of a WorkflowEdge.
func (c *WorkflowEdgeClient) QueryTargetNode(_m *WorkflowEdge) *WorkflowNodeQuery {
	query := (&WorkflowNodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowedge.Table, workflowedge.FieldID, id),
			sqlgraph.To(workflownode.Table, workflownode.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowedge.TargetNodeTable, workflowedge.TargetNodeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowEdgeClient) Hooks() []Hook {
	hooks := c.hooks.WorkflowEdge
	return append(hooks[:len(hooks):len(hooks)], workflowedge.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WorkflowEdgeClient) Interceptors() []Interceptor {
	inters := c.inters.WorkflowEdge
	return append(inters[:len(inters):len(inters)], workflowedge.Interceptors[:]...)
}

func (c *WorkflowEdgeClient) mutate(ctx context.Context, m *WorkflowEdgeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowEdgeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowEdgeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowEdgeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowEdgeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkflowEdge mutation op: %q", m.Op())
	}
}

// WorkflowExecutionClient is a client for the WorkflowExecution schema.
type WorkflowExecutionClient struct {
	config
}

// NewWorkflowExecutionClient returns a client for the WorkflowExecution from the given config.
func NewWorkflowExecutionClient(c config) *WorkflowExecutionClient {
	return &WorkflowExecutionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowexecution.Hooks(f(g(h())))`.
func (c *WorkflowExecutionClient) Use(hooks ...Hook) {
	c.hooks.WorkflowExecution = append(c.hooks.WorkflowExecution, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowexecution.Intercept(f(g(h())))`.
func (c *WorkflowExecutionClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowExecution = append(c.inters.WorkflowExecution, interceptors...)
}

// Create returns a builder for creating a WorkflowExecution entity.
func (c *WorkflowExecutionClient) Create() *WorkflowExecutionCreate {
	mutation := newWorkflowExecutionMutation(c.config, OpCreate)
	return &WorkflowExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowExecution entities.
func (c *WorkflowExecutionClient) CreateBulk(builders ...*WorkflowExecutionCreate) *WorkflowExecutionCreateBulk {
	return &WorkflowExecutionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowExecutionClient) MapCreateBulk(slice any, setFunc func(*WorkflowExecutionCreate, int)) *WorkflowExecutionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowExecutionCreateBulk{err: fmt.Errorf("calling to WorkflowExecutionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowExecutionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowExecutionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowExecution.
func (c *WorkflowExecutionClient) Update() *WorkflowExecutionUpdate {
	mutation := newWorkflowExecutionMutation(c.config, OpUpdate)
	return &WorkflowExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowExecutionClient) UpdateOne(_m *WorkflowExecution) *WorkflowExecutionUpdateOne {
	mutation := newWorkflowExecutionMutation(c.config, OpUpdateOne, withWorkflowExecution(_m))
	return &WorkflowExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowExecutionClient) UpdateOneID(id uint64) *WorkflowExecutionUpdateOne {
	mutation := newWorkflowExecutionMutation(c.config, OpUpdateOne, withWorkflowExecutionID(id))
	return &WorkflowExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowExecution.
func (c *WorkflowExecutionClient) Delete() *WorkflowExecutionDelete {
	mutation := newWorkflowExecutionMutation(c.config, OpDelete)
	return &WorkflowExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowExecutionClient) DeleteOne(_m *WorkflowExecution) *WorkflowExecutionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowExecutionClient) DeleteOneID(id uint64) *WorkflowExecutionDeleteOne {
	builder := c.Delete().Where(workflowexecution.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowExecutionDeleteOne{builder}
}

// Query returns a query builder for WorkflowExecution.
func (c *WorkflowExecutionClient) Query() *WorkflowExecutionQuery {
	return &WorkflowExecutionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowExecution},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowExecution entity by its id.
func (c *WorkflowExecutionClient) Get(ctx context.Context, id uint64) (*WorkflowExecution, error) {
	return c.Query().Where(workflowexecution.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowExecutionClient) GetX(ctx context.Context, id uint64) *WorkflowExecution {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApplication queries the application edge of a WorkflowExecution.
func (c *WorkflowExecutionClient) QueryApplication(_m *WorkflowExecution) *WorkflowApplicationQuery {
	query := (&WorkflowApplicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowexecution.Table, workflowexecution.FieldID, id),
			sqlgraph.To(workflowapplication.Table, workflowapplication.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowexecution.ApplicationTable, workflowexecution.ApplicationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodeExecutions queries the node_executions edge of a WorkflowExecution.
func (c *WorkflowExecutionClient) QueryNodeExecutions(_m *WorkflowExecution) *WorkflowNodeExecutionQuery {
	query := (&WorkflowNodeExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowexecution.Table, workflowexecution.FieldID, id),
			sqlgraph.To(workflownodeexecution.Table, workflownodeexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflowexecution.NodeExecutionsTable, workflowexecution.NodeExecutionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowExecutionClient) Hooks() []Hook {
	hooks := c.hooks.WorkflowExecution
	return append(hooks[:len(hooks):len(hooks)], workflowexecution.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WorkflowExecutionClient) Interceptors() []Interceptor {
	return c.inters.WorkflowExecution
}

func (c *WorkflowExecutionClient) mutate(ctx context.Context, m *WorkflowExecutionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkflowExecution mutation op: %q", m.Op())
	}
}

// WorkflowExecutionLogClient is a client for the WorkflowExecutionLog schema.
type WorkflowExecutionLogClient struct {
	config
}

// NewWorkflowExecutionLogClient returns a client for the WorkflowExecutionLog from the given config.
func NewWorkflowExecutionLogClient(c config) *WorkflowExecutionLogClient {
	return &WorkflowExecutionLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowexecutionlog.Hooks(f(g(h())))`.
func (c *WorkflowExecutionLogClient) Use(hooks ...Hook) {
	c.hooks.WorkflowExecutionLog = append(c.hooks.WorkflowExecutionLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowexecutionlog.Intercept(f(g(h())))`.
func (c *WorkflowExecutionLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowExecutionLog = append(c.inters.WorkflowExecutionLog, interceptors...)
}

// Create returns a builder for creating a WorkflowExecutionLog entity.
func (c *WorkflowExecutionLogClient) Create() *WorkflowExecutionLogCreate {
	mutation := newWorkflowExecutionLogMutation(c.config, OpCreate)
	return &WorkflowExecutionLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowExecutionLog entities.
func (c *WorkflowExecutionLogClient) CreateBulk(builders ...*WorkflowExecutionLogCreate) *WorkflowExecutionLogCreateBulk {
	return &WorkflowExecutionLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowExecutionLogClient) MapCreateBulk(slice any, setFunc func(*WorkflowExecutionLogCreate, int)) *WorkflowExecutionLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowExecutionLogCreateBulk{err: fmt.Errorf("calling to WorkflowExecutionLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowExecutionLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowExecutionLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowExecutionLog.
func (c *WorkflowExecutionLogClient) Update() *WorkflowExecutionLogUpdate {
	mutation := newWorkflowExecutionLogMutation(c.config, OpUpdate)
	return &WorkflowExecutionLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowExecutionLogClient) UpdateOne(_m *WorkflowExecutionLog) *WorkflowExecutionLogUpdateOne {
	mutation := newWorkflowExecutionLogMutation(c.config, OpUpdateOne, withWorkflowExecutionLog(_m))
	return &WorkflowExecutionLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowExecutionLogClient) UpdateOneID(id uint64) *WorkflowExecutionLogUpdateOne {
	mutation := newWorkflowExecutionLogMutation(c.config, OpUpdateOne, withWorkflowExecutionLogID(id))
	return &WorkflowExecutionLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowExecutionLog.
func (c *WorkflowExecutionLogClient) Delete() *WorkflowExecutionLogDelete {
	mutation := newWorkflowExecutionLogMutation(c.config, OpDelete)
	return &WorkflowExecutionLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowExecutionLogClient) DeleteOne(_m *WorkflowExecutionLog) *WorkflowExecutionLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowExecutionLogClient) DeleteOneID(id uint64) *WorkflowExecutionLogDeleteOne {
	builder := c.Delete().Where(workflowexecutionlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowExecutionLogDeleteOne{builder}
}

// Query returns a query builder for WorkflowExecutionLog.
func (c *WorkflowExecutionLogClient) Query() *WorkflowExecutionLogQuery {
	return &WorkflowExecutionLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowExecutionLog},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowExecutionLog entity by its id.
func (c *WorkflowExecutionLogClient) Get(ctx context.Context, id uint64) (*WorkflowExecutionLog, error) {
	return c.Query().Where(workflowexecutionlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowExecutionLogClient) GetX(ctx context.Context, id uint64) *WorkflowExecutionLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WorkflowExecutionLogClient) Hooks() []Hook {
	hooks := c.hooks.WorkflowExecutionLog
	return append(hooks[:len(hooks):len(hooks)], workflowexecutionlog.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WorkflowExecutionLogClient) Interceptors() []Interceptor {
	return c.inters.WorkflowExecutionLog
}

func (c *WorkflowExecutionLogClient) mutate(ctx context.Context, m *WorkflowExecutionLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowExecutionLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowExecutionLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowExecutionLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowExecutionLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkflowExecutionLog mutation op: %q", m.Op())
	}
}

// WorkflowNodeClient is a client for the WorkflowNode schema.
type WorkflowNodeClient struct {
	config
}

// NewWorkflowNodeClient returns a client for the WorkflowNode from the given config.
func NewWorkflowNodeClient(c config) *WorkflowNodeClient {
	return &WorkflowNodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflownode.Hooks(f(g(h())))`.
func (c *WorkflowNodeClient) Use(hooks ...Hook) {
	c.hooks.WorkflowNode = append(c.hooks.WorkflowNode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflownode.Intercept(f(g(h())))`.
func (c *WorkflowNodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowNode = append(c.inters.WorkflowNode, interceptors...)
}

// Create returns a builder for creating a WorkflowNode entity.
func (c *WorkflowNodeClient) Create() *WorkflowNodeCreate {
	mutation := newWorkflowNodeMutation(c.config, OpCreate)
	return &WorkflowNodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowNode entities.
func (c *WorkflowNodeClient) CreateBulk(builders ...*WorkflowNodeCreate) *WorkflowNodeCreateBulk {
	return &WorkflowNodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowNodeClient) MapCreateBulk(slice any, setFunc func(*WorkflowNodeCreate, int)) *WorkflowNodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowNodeCreateBulk{err: fmt.Errorf("calling to WorkflowNodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowNodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowNodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowNode.
func (c *WorkflowNodeClient) Update() *WorkflowNodeUpdate {
	mutation := newWorkflowNodeMutation(c.config, OpUpdate)
	return &WorkflowNodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowNodeClient) UpdateOne(_m *WorkflowNode) *WorkflowNodeUpdateOne {
	mutation := newWorkflowNodeMutation(c.config, OpUpdateOne, withWorkflowNode(_m))
	return &WorkflowNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowNodeClient) UpdateOneID(id uint64) *WorkflowNodeUpdateOne {
	mutation := newWorkflowNodeMutation(c.config, OpUpdateOne, withWorkflowNodeID(id))
	return &WorkflowNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowNode.
func (c *WorkflowNodeClient) Delete() *WorkflowNodeDelete {
	mutation := newWorkflowNodeMutation(c.config, OpDelete)
	return &WorkflowNodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowNodeClient) DeleteOne(_m *WorkflowNode) *WorkflowNodeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowNodeClient) DeleteOneID(id uint64) *WorkflowNodeDeleteOne {
	builder := c.Delete().Where(workflownode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowNodeDeleteOne{builder}
}

// Query returns a query builder for WorkflowNode.
func (c *WorkflowNodeClient) Query() *WorkflowNodeQuery {
	return &WorkflowNodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowNode},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowNode entity by its id.
func (c *WorkflowNodeClient) Get(ctx context.Context, id uint64) (*WorkflowNode, error) {
	return c.Query().Where(workflownode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowNodeClient) GetX(ctx context.Context, id uint64) *WorkflowNode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApplication queries the application edge of a WorkflowNode.
func (c *WorkflowNodeClient) QueryApplication(_m *WorkflowNode) *WorkflowApplicationQuery {
	query := (&WorkflowApplicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflownode.Table, workflownode.FieldID, id),
			sqlgraph.To(workflowapplication.Table, workflowapplication.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflownode.ApplicationTable, workflownode.ApplicationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutions queries the executions edge of a WorkflowNode.
func (c *WorkflowNodeClient) QueryExecutions(_m *WorkflowNode) *WorkflowNodeExecutionQuery {
	query := (&WorkflowNodeExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflownode.Table, workflownode.FieldID, id),
			sqlgraph.To(workflownodeexecution.Table, workflownodeexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflownode.ExecutionsTable, workflownode.ExecutionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOutgoingEdges queries the outgoing_edges edge of a WorkflowNode.
func (c *WorkflowNodeClient) QueryOutgoingEdges(_m *WorkflowNode) *WorkflowEdgeQuery {
	query := (&WorkflowEdgeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflownode.Table, workflownode.FieldID, id),
			sqlgraph.To(workflowedge.Table, workflowedge.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflownode.OutgoingEdgesTable, workflownode.OutgoingEdgesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncomingEdges queries the incoming_edges edge of a WorkflowNode.
func (c *WorkflowNodeClient) QueryIncomingEdges(_m *WorkflowNode) *WorkflowEdgeQuery {
	query := (&WorkflowEdgeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflownode.Table, workflownode.FieldID, id),
			sqlgraph.To(workflowedge.Table, workflowedge.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflownode.IncomingEdgesTable, workflownode.IncomingEdgesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowNodeClient) Hooks() []Hook {
	hooks := c.hooks.WorkflowNode
	return append(hooks[:len(hooks):len(hooks)], workflownode.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WorkflowNodeClient) Interceptors() []Interceptor {
	inters := c.inters.WorkflowNode
	return append(inters[:len(inters):len(inters)], workflownode.Interceptors[:]...)
}

func (c *WorkflowNodeClient) mutate(ctx context.Context, m *WorkflowNodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowNodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowNodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowNodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkflowNode mutation op: %q", m.Op())
	}
}

// WorkflowNodeExecutionClient is a client for the WorkflowNodeExecution schema.
type WorkflowNodeExecutionClient struct {
	config
}

// NewWorkflowNodeExecutionClient returns a client for the WorkflowNodeExecution from the given config.
func NewWorkflowNodeExecutionClient(c config) *WorkflowNodeExecutionClient {
	return &WorkflowNodeExecutionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflownodeexecution.Hooks(f(g(h())))`.
func (c *WorkflowNodeExecutionClient) Use(hooks ...Hook) {
	c.hooks.WorkflowNodeExecution = append(c.hooks.WorkflowNodeExecution, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflownodeexecution.Intercept(f(g(h())))`.
func (c *WorkflowNodeExecutionClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowNodeExecution = append(c.inters.WorkflowNodeExecution, interceptors...)
}

// Create returns a builder for creating a WorkflowNodeExecution entity.
func (c *WorkflowNodeExecutionClient) Create() *WorkflowNodeExecutionCreate {
	mutation := newWorkflowNodeExecutionMutation(c.config, OpCreate)
	return &WorkflowNodeExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowNodeExecution entities.
func (c *WorkflowNodeExecutionClient) CreateBulk(builders ...*WorkflowNodeExecutionCreate) *WorkflowNodeExecutionCreateBulk {
	return &WorkflowNodeExecutionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowNodeExecutionClient) MapCreateBulk(slice any, setFunc func(*WorkflowNodeExecutionCreate, int)) *WorkflowNodeExecutionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowNodeExecutionCreateBulk{err: fmt.Errorf("calling to WorkflowNodeExecutionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowNodeExecutionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowNodeExecutionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowNodeExecution.
func (c *WorkflowNodeExecutionClient) Update() *WorkflowNodeExecutionUpdate {
	mutation := newWorkflowNodeExecutionMutation(c.config, OpUpdate)
	return &WorkflowNodeExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowNodeExecutionClient) UpdateOne(_m *WorkflowNodeExecution) *WorkflowNodeExecutionUpdateOne {
	mutation := newWorkflowNodeExecutionMutation(c.config, OpUpdateOne, withWorkflowNodeExecution(_m))
	return &WorkflowNodeExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowNodeExecutionClient) UpdateOneID(id uint64) *WorkflowNodeExecutionUpdateOne {
	mutation := newWorkflowNodeExecutionMutation(c.config, OpUpdateOne, withWorkflowNodeExecutionID(id))
	return &WorkflowNodeExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowNodeExecution.
func (c *WorkflowNodeExecutionClient) Delete() *WorkflowNodeExecutionDelete {
	mutation := newWorkflowNodeExecutionMutation(c.config, OpDelete)
	return &WorkflowNodeExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowNodeExecutionClient) DeleteOne(_m *WorkflowNodeExecution) *WorkflowNodeExecutionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowNodeExecutionClient) DeleteOneID(id uint64) *WorkflowNodeExecutionDeleteOne {
	builder := c.Delete().Where(workflownodeexecution.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowNodeExecutionDeleteOne{builder}
}

// Query returns a query builder for WorkflowNodeExecution.
func (c *WorkflowNodeExecutionClient) Query() *WorkflowNodeExecutionQuery {
	return &WorkflowNodeExecutionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowNodeExecution},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowNodeExecution entity by its id.
func (c *WorkflowNodeExecutionClient) Get(ctx context.Context, id uint64) (*WorkflowNodeExecution, error) {
	return c.Query().Where(workflownodeexecution.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowNodeExecutionClient) GetX(ctx context.Context, id uint64) *WorkflowNodeExecution {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflowExecution queries the workflow_execution edge of a WorkflowNodeExecution.
func (c *WorkflowNodeExecutionClient) QueryWorkflowExecution(_m *WorkflowNodeExecution) *WorkflowExecutionQuery {
	query := (&WorkflowExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflownodeexecution.Table, workflownodeexecution.FieldID, id),
			sqlgraph.To(workflowexecution.Table, workflowexecution.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflownodeexecution.WorkflowExecutionTable, workflownodeexecution.WorkflowExecutionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNode queries the node edge of a WorkflowNodeExecution.
func (c *WorkflowNodeExecutionClient) QueryNode(_m *WorkflowNodeExecution) *WorkflowNodeQuery {
	query := (&WorkflowNodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflownodeexecution.Table, workflownodeexecution.FieldID, id),
			sqlgraph.To(workflownode.Table, workflownode.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflownodeexecution.NodeTable, workflownodeexecution.NodeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowNodeExecutionClient) Hooks() []Hook {
	hooks := c.hooks.WorkflowNodeExecution
	return append(hooks[:len(hooks):len(hooks)], workflownodeexecution.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WorkflowNodeExecutionClient) Interceptors() []Interceptor {
	return c.inters.WorkflowNodeExecution
}

func (c *WorkflowNodeExecutionClient) mutate(ctx context.Context, m *WorkflowNodeExecutionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowNodeExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowNodeExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowNodeExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowNodeExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkflowNodeExecution mutation op: %q", m.Op())
	}
}

// WorkflowVersionClient is a client for the WorkflowVersion schema.
type WorkflowVersionClient struct {
	config
}

// NewWorkflowVersionClient returns a client for the WorkflowVersion from the given config.
func NewWorkflowVersionClient(c config) *WorkflowVersionClient {
	return &WorkflowVersionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowversion.Hooks(f(g(h())))`.
func (c *WorkflowVersionClient) Use(hooks ...Hook) {
	c.hooks.WorkflowVersion = append(c.hooks.WorkflowVersion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowversion.Intercept(f(g(h())))`.
func (c *WorkflowVersionClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowVersion = append(c.inters.WorkflowVersion, interceptors...)
}

// Create returns a builder for creating a WorkflowVersion entity.
func (c *WorkflowVersionClient) Create() *WorkflowVersionCreate {
	mutation := newWorkflowVersionMutation(c.config, OpCreate)
	return &WorkflowVersionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowVersion entities.
func (c *WorkflowVersionClient) CreateBulk(builders ...*WorkflowVersionCreate) *WorkflowVersionCreateBulk {
	return &WorkflowVersionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowVersionClient) MapCreateBulk(slice any, setFunc func(*WorkflowVersionCreate, int)) *WorkflowVersionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowVersionCreateBulk{err: fmt.Errorf("calling to WorkflowVersionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowVersionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowVersionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowVersion.
func (c *WorkflowVersionClient) Update() *WorkflowVersionUpdate {
	mutation := newWorkflowVersionMutation(c.config, OpUpdate)
	return &WorkflowVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowVersionClient) UpdateOne(_m *WorkflowVersion) *WorkflowVersionUpdateOne {
	mutation := newWorkflowVersionMutation(c.config, OpUpdateOne, withWorkflowVersion(_m))
	return &WorkflowVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowVersionClient) UpdateOneID(id uint64) *WorkflowVersionUpdateOne {
	mutation := newWorkflowVersionMutation(c.config, OpUpdateOne, withWorkflowVersionID(id))
	return &WorkflowVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowVersion.
func (c *WorkflowVersionClient) Delete() *WorkflowVersionDelete {
	mutation := newWorkflowVersionMutation(c.config, OpDelete)
	return &WorkflowVersionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowVersionClient) DeleteOne(_m *WorkflowVersion) *WorkflowVersionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowVersionClient) DeleteOneID(id uint64) *WorkflowVersionDeleteOne {
	builder := c.Delete().Where(workflowversion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowVersionDeleteOne{builder}
}

// Query returns a query builder for WorkflowVersion.
func (c *WorkflowVersionClient) Query() *WorkflowVersionQuery {
	return &WorkflowVersionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowVersion},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowVersion entity by its id.
func (c *WorkflowVersionClient) Get(ctx context.Context, id uint64) (*WorkflowVersion, error) {
	return c.Query().Where(workflowversion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowVersionClient) GetX(ctx context.Context, id uint64) *WorkflowVersion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WorkflowVersionClient) Hooks() []Hook {
	hooks := c.hooks.WorkflowVersion
	return append(hooks[:len(hooks):len(hooks)], workflowversion.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WorkflowVersionClient) Interceptors() []Interceptor {
	return c.inters.WorkflowVersion
}

func (c *WorkflowVersionClient) mutate(ctx context.Context, m *WorkflowVersionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowVersionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowVersionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkflowVersion mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		APIAuth, Address, Area, Attachment, ClientDevice, Credential, Logging,
		LoginRecord, OauthApplication, OauthAuthorizationCode, OauthProvider,
		OauthState, OauthToken, OauthUser, OauthUserAuthorization, Permission, Role,
		RolePermission, Scan, Scope, Station, Subway, SubwayStation, SystemMonitor,
		User, UserRole, VerifyCode, WorkflowApplication, WorkflowEdge,
		WorkflowExecution, WorkflowExecutionLog, WorkflowNode, WorkflowNodeExecution,
		WorkflowVersion []ent.Hook
	}
	inters struct {
		APIAuth, Address, Area, Attachment, ClientDevice, Credential, Logging,
		LoginRecord, OauthApplication, OauthAuthorizationCode, OauthProvider,
		OauthState, OauthToken, OauthUser, OauthUserAuthorization, Permission, Role,
		RolePermission, Scan, Scope, Station, Subway, SubwayStation, SystemMonitor,
		User, UserRole, VerifyCode, WorkflowApplication, WorkflowEdge,
		WorkflowExecution, WorkflowExecutionLog, WorkflowNode, WorkflowNodeExecution,
		WorkflowVersion []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
