// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"go-backend/database/ent/area"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// Area is the model entity for the Area schema.
type Area struct {
	config `json:"-"`
	// ID of the ent.
	// 主键ID
	ID uint64 `json:"id,omitempty"`
	// 创建时间
	CreateTime time.Time `json:"create_time,omitempty"`
	// 创建人ID
	CreateBy uint64 `json:"create_by,omitempty"`
	// 更新时间
	UpdateTime time.Time `json:"update_time,omitempty"`
	// 更新人ID
	UpdateBy uint64 `json:"update_by,omitempty"`
	// 删除时间
	DeleteTime time.Time `json:"delete_time,omitempty"`
	// 删除人ID
	DeleteBy uint64 `json:"delete_by,omitempty"`
	// 地区名称
	Name string `json:"name,omitempty"`
	// 层级类型
	Level area.Level `json:"level,omitempty"`
	// 深度: 0=国家、1=省、2=市、3=区、4=街道
	Depth int `json:"depth,omitempty"`
	// 地区编码(国家标准行政区划代码)
	Code string `json:"code,omitempty"`
	// 纬度
	Latitude float64 `json:"latitude,omitempty"`
	// 经度
	Longitude float64 `json:"longitude,omitempty"`
	// 上级地区ID
	ParentID uint64 `json:"parent_id,omitempty"`
	// 界面显示颜色
	Color string `json:"color,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the AreaQuery when eager-loading is set.
	Edges        AreaEdges `json:"edges"`
	selectValues sql.SelectValues
}

// AreaEdges holds the relations/edges for other nodes in the graph.
type AreaEdges struct {
	// Children holds the value of the children edge.
	Children []*Area `json:"children,omitempty"`
	// Parent holds the value of the parent edge.
	Parent *Area `json:"parent,omitempty"`
	// Addresses holds the value of the addresses edge.
	Addresses []*Address `json:"addresses,omitempty"`
	// Stations holds the value of the stations edge.
	Stations []*Station `json:"stations,omitempty"`
	// Subways holds the value of the subways edge.
	Subways []*Subway `json:"subways,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes    [5]bool
	namedChildren  map[string][]*Area
	namedAddresses map[string][]*Address
	namedStations  map[string][]*Station
	namedSubways   map[string][]*Subway
}

// ChildrenOrErr returns the Children value or an error if the edge
// was not loaded in eager-loading.
func (e AreaEdges) ChildrenOrErr() ([]*Area, error) {
	if e.loadedTypes[0] {
		return e.Children, nil
	}
	return nil, &NotLoadedError{edge: "children"}
}

// ParentOrErr returns the Parent value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e AreaEdges) ParentOrErr() (*Area, error) {
	if e.Parent != nil {
		return e.Parent, nil
	} else if e.loadedTypes[1] {
		return nil, &NotFoundError{label: area.Label}
	}
	return nil, &NotLoadedError{edge: "parent"}
}

// AddressesOrErr returns the Addresses value or an error if the edge
// was not loaded in eager-loading.
func (e AreaEdges) AddressesOrErr() ([]*Address, error) {
	if e.loadedTypes[2] {
		return e.Addresses, nil
	}
	return nil, &NotLoadedError{edge: "addresses"}
}

// StationsOrErr returns the Stations value or an error if the edge
// was not loaded in eager-loading.
func (e AreaEdges) StationsOrErr() ([]*Station, error) {
	if e.loadedTypes[3] {
		return e.Stations, nil
	}
	return nil, &NotLoadedError{edge: "stations"}
}

// SubwaysOrErr returns the Subways value or an error if the edge
// was not loaded in eager-loading.
func (e AreaEdges) SubwaysOrErr() ([]*Subway, error) {
	if e.loadedTypes[4] {
		return e.Subways, nil
	}
	return nil, &NotLoadedError{edge: "subways"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Area) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case area.FieldLatitude, area.FieldLongitude:
			values[i] = new(sql.NullFloat64)
		case area.FieldID, area.FieldCreateBy, area.FieldUpdateBy, area.FieldDeleteBy, area.FieldDepth, area.FieldParentID:
			values[i] = new(sql.NullInt64)
		case area.FieldName, area.FieldLevel, area.FieldCode, area.FieldColor:
			values[i] = new(sql.NullString)
		case area.FieldCreateTime, area.FieldUpdateTime, area.FieldDeleteTime:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Area fields.
func (_m *Area) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case area.FieldID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				_m.ID = uint64(value.Int64)
			}
		case area.FieldCreateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field create_time", values[i])
			} else if value.Valid {
				_m.CreateTime = value.Time
			}
		case area.FieldCreateBy:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field create_by", values[i])
			} else if value.Valid {
				_m.CreateBy = uint64(value.Int64)
			}
		case area.FieldUpdateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field update_time", values[i])
			} else if value.Valid {
				_m.UpdateTime = value.Time
			}
		case area.FieldUpdateBy:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field update_by", values[i])
			} else if value.Valid {
				_m.UpdateBy = uint64(value.Int64)
			}
		case area.FieldDeleteTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field delete_time", values[i])
			} else if value.Valid {
				_m.DeleteTime = value.Time
			}
		case area.FieldDeleteBy:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field delete_by", values[i])
			} else if value.Valid {
				_m.DeleteBy = uint64(value.Int64)
			}
		case area.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				_m.Name = value.String
			}
		case area.FieldLevel:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field level", values[i])
			} else if value.Valid {
				_m.Level = area.Level(value.String)
			}
		case area.FieldDepth:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field depth", values[i])
			} else if value.Valid {
				_m.Depth = int(value.Int64)
			}
		case area.FieldCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field code", values[i])
			} else if value.Valid {
				_m.Code = value.String
			}
		case area.FieldLatitude:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field latitude", values[i])
			} else if value.Valid {
				_m.Latitude = value.Float64
			}
		case area.FieldLongitude:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field longitude", values[i])
			} else if value.Valid {
				_m.Longitude = value.Float64
			}
		case area.FieldParentID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field parent_id", values[i])
			} else if value.Valid {
				_m.ParentID = uint64(value.Int64)
			}
		case area.FieldColor:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field color", values[i])
			} else if value.Valid {
				_m.Color = value.String
			}
		default:
			_m.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Area.
// This includes values selected through modifiers, order, etc.
func (_m *Area) Value(name string) (ent.Value, error) {
	return _m.selectValues.Get(name)
}

// QueryChildren queries the "children" edge of the Area entity.
func (_m *Area) QueryChildren() *AreaQuery {
	return NewAreaClient(_m.config).QueryChildren(_m)
}

// QueryParent queries the "parent" edge of the Area entity.
func (_m *Area) QueryParent() *AreaQuery {
	return NewAreaClient(_m.config).QueryParent(_m)
}

// QueryAddresses queries the "addresses" edge of the Area entity.
func (_m *Area) QueryAddresses() *AddressQuery {
	return NewAreaClient(_m.config).QueryAddresses(_m)
}

// QueryStations queries the "stations" edge of the Area entity.
func (_m *Area) QueryStations() *StationQuery {
	return NewAreaClient(_m.config).QueryStations(_m)
}

// QuerySubways queries the "subways" edge of the Area entity.
func (_m *Area) QuerySubways() *SubwayQuery {
	return NewAreaClient(_m.config).QuerySubways(_m)
}

// Update returns a builder for updating this Area.
// Note that you need to call Area.Unwrap() before calling this method if this Area
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *Area) Update() *AreaUpdateOne {
	return NewAreaClient(_m.config).UpdateOne(_m)
}

// Unwrap unwraps the Area entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *Area) Unwrap() *Area {
	_tx, ok := _m.config.driver.(*txDriver)
	if !ok {
		panic("ent: Area is not a transactional entity")
	}
	_m.config.driver = _tx.drv
	return _m
}

// String implements the fmt.Stringer.
func (_m *Area) String() string {
	var builder strings.Builder
	builder.WriteString("Area(")
	builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
	builder.WriteString("create_time=")
	builder.WriteString(_m.CreateTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("create_by=")
	builder.WriteString(fmt.Sprintf("%v", _m.CreateBy))
	builder.WriteString(", ")
	builder.WriteString("update_time=")
	builder.WriteString(_m.UpdateTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("update_by=")
	builder.WriteString(fmt.Sprintf("%v", _m.UpdateBy))
	builder.WriteString(", ")
	builder.WriteString("delete_time=")
	builder.WriteString(_m.DeleteTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("delete_by=")
	builder.WriteString(fmt.Sprintf("%v", _m.DeleteBy))
	builder.WriteString(", ")
	builder.WriteString("name=")
	builder.WriteString(_m.Name)
	builder.WriteString(", ")
	builder.WriteString("level=")
	builder.WriteString(fmt.Sprintf("%v", _m.Level))
	builder.WriteString(", ")
	builder.WriteString("depth=")
	builder.WriteString(fmt.Sprintf("%v", _m.Depth))
	builder.WriteString(", ")
	builder.WriteString("code=")
	builder.WriteString(_m.Code)
	builder.WriteString(", ")
	builder.WriteString("latitude=")
	builder.WriteString(fmt.Sprintf("%v", _m.Latitude))
	builder.WriteString(", ")
	builder.WriteString("longitude=")
	builder.WriteString(fmt.Sprintf("%v", _m.Longitude))
	builder.WriteString(", ")
	builder.WriteString("parent_id=")
	builder.WriteString(fmt.Sprintf("%v", _m.ParentID))
	builder.WriteString(", ")
	builder.WriteString("color=")
	builder.WriteString(_m.Color)
	builder.WriteByte(')')
	return builder.String()
}

// NamedChildren returns the Children named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *Area) NamedChildren(name string) ([]*Area, error) {
	if _m.Edges.namedChildren == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedChildren[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *Area) appendNamedChildren(name string, edges ...*Area) {
	if _m.Edges.namedChildren == nil {
		_m.Edges.namedChildren = make(map[string][]*Area)
	}
	if len(edges) == 0 {
		_m.Edges.namedChildren[name] = []*Area{}
	} else {
		_m.Edges.namedChildren[name] = append(_m.Edges.namedChildren[name], edges...)
	}
}

// NamedAddresses returns the Addresses named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *Area) NamedAddresses(name string) ([]*Address, error) {
	if _m.Edges.namedAddresses == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedAddresses[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *Area) appendNamedAddresses(name string, edges ...*Address) {
	if _m.Edges.namedAddresses == nil {
		_m.Edges.namedAddresses = make(map[string][]*Address)
	}
	if len(edges) == 0 {
		_m.Edges.namedAddresses[name] = []*Address{}
	} else {
		_m.Edges.namedAddresses[name] = append(_m.Edges.namedAddresses[name], edges...)
	}
}

// NamedStations returns the Stations named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *Area) NamedStations(name string) ([]*Station, error) {
	if _m.Edges.namedStations == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedStations[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *Area) appendNamedStations(name string, edges ...*Station) {
	if _m.Edges.namedStations == nil {
		_m.Edges.namedStations = make(map[string][]*Station)
	}
	if len(edges) == 0 {
		_m.Edges.namedStations[name] = []*Station{}
	} else {
		_m.Edges.namedStations[name] = append(_m.Edges.namedStations[name], edges...)
	}
}

// NamedSubways returns the Subways named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *Area) NamedSubways(name string) ([]*Subway, error) {
	if _m.Edges.namedSubways == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedSubways[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *Area) appendNamedSubways(name string, edges ...*Subway) {
	if _m.Edges.namedSubways == nil {
		_m.Edges.namedSubways = make(map[string][]*Subway)
	}
	if len(edges) == 0 {
		_m.Edges.namedSubways[name] = []*Subway{}
	} else {
		_m.Edges.namedSubways[name] = append(_m.Edges.namedSubways[name], edges...)
	}
}

// Areas is a parsable slice of Area.
type Areas []*Area
